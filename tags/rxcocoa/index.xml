<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rxcocoa on rx_marin&lt;blog&gt;</title>
    <link>http://rx-marin.com/tags/rxcocoa/</link>
    <description>Recent content in Rxcocoa on rx_marin&lt;blog&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Feb 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://rx-marin.com/tags/rxcocoa/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Split laps timer with RxSwift and RxCocoa: Part 2</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/</guid>
      <description>&lt;p&gt;In my post from last week I worked on creating a split lapse timer app (&lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/&#34;&gt;last week&amp;rsquo;s post&lt;/a&gt;). But later on when I was playing with the application I noticed that I naturally would like to have means to start or stop the timer.&lt;/p&gt;

&lt;p&gt;Well this week I am implementing exactly this functionality.&lt;/p&gt;

&lt;p&gt;The first thing I thought about was how to implement state in my app because a timer clearly has two distinct states either running or not running. That got me thinking about combining signals, mapping, you know, all the good stuff.&lt;/p&gt;

&lt;p&gt;If you want to follow along you can download the starter project I prepared. It is in the shape where last weeks blog posts leaves off but I&amp;rsquo;ve added a couple of buttons in the user interface:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/latimer-new-ui.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Download the starter project to follow along here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer_starter.zip&#34;&gt;rx_laptimer_starter.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s put all those buttons to work!&lt;/p&gt;

&lt;p&gt;My very first idea was to try generating a sequence of values to describe the current state of the timer. The start button would produce &lt;code&gt;true&lt;/code&gt; values and the stop button will produce &lt;code&gt;false&lt;/code&gt; values. When merged I will get one sequence that emits every time the state changes:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;o---- (play tap) true--- (stop tap) false --- (play tap) true ---&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So at the top of &lt;code&gt;viewDidLoad()&lt;/code&gt; I created a new Observable like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isRunning = [btnPlay.rx_tap.map({_ in true}), btnStop.rx_tap.map({_ in false})]
    .toObservable()
    .merge()
    .startWith(false)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I mapped the taps on &lt;code&gt;btnPlay&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; and the taps on &lt;code&gt;btnStop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; and merged them together.&lt;/p&gt;

&lt;p&gt;The Observable starts with a &lt;code&gt;false&lt;/code&gt; value to give the user the opportunity to start the timer at their convenience.&lt;/p&gt;

&lt;p&gt;I printed the values the new observable emits and was quite happy with the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;isRunning.subscribeNext({state in
    print(state)
}).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code printed &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; in the console each time I pressed play or stop. Neato!&lt;/p&gt;

&lt;p&gt;Now it looked very easy to bind that Observable to the buttons&amp;rsquo; &lt;code&gt;rx_enabled&lt;/code&gt; property to actually make the UI reflect the timer state. I could as well hide the laps button when the timer isn&amp;rsquo;t running at all!&lt;/p&gt;

&lt;p&gt;And since some of the controls needed to be enabled when the timer is running and others when it isn&amp;rsquo;t - I made myself yet another observable and bound the controls like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isntRunning = isRunning.map({running in !running}).shareReplay(1)

isRunning.bindTo(btnStop.rx_enabled).addDisposableTo(bag)
isntRunning.bindTo(btnLap.rx_hidden).addDisposableTo(bag)
isntRunning.bindTo(btnPlay.rx_enabled).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The stop button is enabled while the timer is running. Play is enabled when the timer is paused.&lt;/p&gt;

&lt;p&gt;I really love this kind of code. No &lt;code&gt;if&lt;/code&gt;s no &lt;code&gt;switch&lt;/code&gt;es; once you get the code running it&amp;rsquo;s very difficult to mess up and there&amp;rsquo;s simply no space for introducing bugs. Everything is air-tight.&lt;/p&gt;

&lt;p&gt;The app started with the laps button hidden and only the play button enabled like so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-play.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Further you could click play just once because it instantly became disabled. How cool :]&lt;/p&gt;

&lt;p&gt;Now my problem was that even though the UI already reflected the different states of the timer - well &amp;hellip; the timer didn&amp;rsquo;t care at all about any of that :]&lt;/p&gt;

&lt;p&gt;I looked into the &lt;code&gt;RxSwift&lt;/code&gt; implementation of a timer but didn&amp;rsquo;t find a way how to pause it (I guess that it couldn&amp;rsquo;t implement state, who knows &amp;hellip;). That&amp;rsquo;s why I thought I&amp;rsquo;d move away from directly binding the timer to the UI and implement my own counter.&lt;/p&gt;

&lt;p&gt;At the time my timer looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, I thought, I just need to somehow combine &lt;code&gt;isRunning&lt;/code&gt; and &lt;code&gt;timer&lt;/code&gt; and filter the observable output when &lt;code&gt;isRunning&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So I did the following: I appended to the existing &lt;code&gt;timer&lt;/code&gt; an operator to combine it with the latest value from &lt;code&gt;isRunning&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.withLatestFrom(isRunning, resultSelector: {_, running in running})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You see that I just ignored the value emitted by &lt;code&gt;timer&lt;/code&gt; since I never use it for anything and return from &lt;code&gt;withLatestFrom&lt;/code&gt; the unchanged &lt;code&gt;running&lt;/code&gt; input parameter:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(Int, Boolean) -&amp;gt; withLatestFrom -&amp;gt; Boolean&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Next I could simply use &lt;code&gt;filter&lt;/code&gt; to stop the observable from emitting when the timer is not running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.filter({running in running})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And last but not least I had to attach a counter, but that was already something I knew how to do with &lt;code&gt;scan&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.scan(0, accumulator: {(acc, _) in
    return acc+1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What &lt;code&gt;scan&lt;/code&gt; does above is to count how many times the timer fired while &lt;code&gt;isRunning&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; (which is exactly what I wanted).&lt;/p&gt;

&lt;p&gt;Finally I had to set the initial value to show in the UI and to share the result between all observers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; .startWith(0)
 .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete code of the enhanced timer observable looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)
    .withLatestFrom(isRunning, resultSelector: {_, running in running})
    .filter({running in running})
    .scan(0, accumulator: {(acc, _) in
        return acc+1
    })
    .startWith(0)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s a wrap :] Now my timer app had a stateful UI and split lap all implemented without a single &lt;code&gt;if&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-2-final.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can get the completed project from here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer_finished.zip&#34;&gt;rx_laptimer_finished.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on  Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Split laps timer with RxSwift and RxCocoa</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/</link>
      <pubDate>Tue, 16 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/</guid>
      <description>

&lt;p&gt;I was browsing through &lt;a href=&#34;http://rxmarbles.com/&#34;&gt;RxMarbles&lt;/a&gt; and was totally baffled by the &lt;code&gt;sample&lt;/code&gt; function. The marble diagram looks pretty random at first sight:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/marbles-sample.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At first I thought - &amp;ldquo;Hey, that second sequence is getting totally ignored!&amp;rdquo;. But after I read the description I figured it out:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The first sequence&amp;rsquo;s elements is &lt;strong&gt;what&lt;/strong&gt; &lt;code&gt;sample&lt;/code&gt; emits, while the second sequence&amp;rsquo;s elements determine &lt;strong&gt;when&lt;/strong&gt; &lt;code&gt;sample&lt;/code&gt; emits. So in a way yes - the actual values A, B, C, D do get totally ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When it was clear to me what &lt;code&gt;sample&lt;/code&gt; does I started wondering if this function has any practical application :]&lt;/p&gt;

&lt;p&gt;This brought me to creating a split lap timer app to test what &lt;code&gt;sample&lt;/code&gt; can do for me. In the finished project I have a timer emitting time values (aka the first sequence) and I want to grab (or sample) the values whenever the user taps a button (aka the second sequence).&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the marble diagram looks like for the app setup:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/sample-dia.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this is how the app looks like when finished:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-finished.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s build that app :]&lt;/p&gt;

&lt;p&gt;Here are the specs I wanted for my split lap timer app:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;start the timer at launch&lt;/li&gt;
&lt;li&gt;show the running time in format MM:SS.MS&lt;/li&gt;
&lt;li&gt;when the user taps &amp;ldquo;Split Lap&amp;rdquo; add a split time&lt;/li&gt;
&lt;li&gt;show a table of the split times&lt;/li&gt;
&lt;li&gt;show a table head with the total of laps&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-start-a-timer:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;1 Start a timer&lt;/h3&gt;

&lt;p&gt;Like in my &lt;a href=&#34;http://rx-marin.com/post/rxswift-timer-sequence-manual-dispose-bag/&#34;&gt;previous post&lt;/a&gt; about manually disposing bag&amp;rsquo;s contents I added a timer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var timer: Observable&amp;lt;NSInteger&amp;gt;!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in &lt;code&gt;viewDidLoad&lt;/code&gt; let it run every &lt;code&gt;1/10&lt;/code&gt; of a second (I chose to show only 1 digit for milliseconds so no need to fire more often):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//create the timer
timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)

timer.subscribeNext({ msecs -&amp;gt; Void in
  print(&amp;quot;\(msecs)00ms&amp;quot;)
}).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This got the timer running and filling up the console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;000ms
100ms
200ms
300ms
400ms
500ms
600ms
700ms
800ms
900ms
1000ms
1100ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool - that was easy (well, I already knew how to do that part, lol)&lt;/p&gt;

&lt;h3 id=&#34;2-show-the-current-elapsed-time:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;2 Show the current elapsed time&lt;/h3&gt;

&lt;p&gt;This was also a part I already knew how to do. First I put together a little function to take the elapsed time and return a nicely formatted string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func stringFromTimeInterval(ms: NSInteger) -&amp;gt; String {
  return String(format: &amp;quot;%0.2d:%0.2d.%0.1d&amp;quot;,
    arguments: [(ms / 600) % 600, (ms % 600 ) / 10, ms % 10])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then back in &lt;code&gt;viewDidLoad&lt;/code&gt; I used it to bind the timer to a label I added via Interface Builder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//wire the chrono
timer.map(stringFromTimeInterval)
  .bindTo(lblChrono.rx_text)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really love how the code flows and tells the story of what should happen:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;timer -&amp;gt; 1,2,3 -&amp;gt; stringFromTimeInterval -&amp;gt; &amp;quot;string&amp;quot;, &amp;quot;string&amp;quot; -&amp;gt; lblChrono&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Functional code is awesome because I get 2 huge wins for free: I can easily reuse &lt;code&gt;stringFromTimeInterval&lt;/code&gt; and I can write very simple tests for it.&lt;/p&gt;

&lt;p&gt;At this point the timer label already displayed the elapsed time:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-label.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-grab-the-split-time-when-the-user-taps-the-split-lap-button:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;3 Grab the split time when the user taps the &amp;ldquo;Split Lap&amp;rdquo; button&lt;/h3&gt;

&lt;p&gt;Ok here I was supposed to have my ultimate win by using &lt;code&gt;sample&lt;/code&gt;. The first few tries didn&amp;rsquo;t get me far until I realized that the &lt;code&gt;rx_tap&lt;/code&gt; property on &lt;code&gt;UIButton&lt;/code&gt; is also an &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Duh, everything is an &lt;code&gt;Observable&lt;/code&gt; :]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then it was just a matter of calling &lt;code&gt;sample&lt;/code&gt; on my timer and providing as a control sequence the &lt;code&gt;rx_tap&lt;/code&gt; property of the button like so: &lt;code&gt;timer.sample(btnLap.rx_tap)&lt;/code&gt; Whaaaat?&lt;/p&gt;

&lt;p&gt;Now each time I tapped the button &lt;code&gt;sample&lt;/code&gt; emitted the latest value produced by &lt;code&gt;timer&lt;/code&gt;. And since I wasn&amp;rsquo;t interested in the number but in the formatted string I again mapped the result with &lt;code&gt;stringFromTimeInterval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And since I needed to build a list of those split times I used &lt;code&gt;scan&lt;/code&gt;. Actually at first I came around &lt;code&gt;reduce&lt;/code&gt; because I was thinking of accumulating values in a list, but then realized I needed to produce a sequence that emits the list for each new value&amp;hellip; hence I kind of knew I got to use &lt;code&gt;scan&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let lapsSequence = timer.sample(btnLap.rx_tap)
    .map(stringFromTimeInterval)
    .scan([String](), accumulator: {lapTimes, newTime in
        return lapTimes + [newTime]
    })
    .shareReplay(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So - each time &lt;code&gt;sample&lt;/code&gt; emits a new lap time &lt;code&gt;scan&lt;/code&gt; emits an array of all the split times so far.&lt;/p&gt;

&lt;p&gt;Not sure how to explain &lt;code&gt;scan&lt;/code&gt; more simply but I&amp;rsquo;ll try: In RxSwift any time you&amp;rsquo;re thinking of using &lt;code&gt;reduce&lt;/code&gt; chances are you need &lt;code&gt;scan&lt;/code&gt; instead :]&lt;/p&gt;

&lt;h3 id=&#34;4-show-a-table-of-the-split-times-so-far:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;4 Show a table of the split times so far&lt;/h3&gt;

&lt;p&gt;Ok so I got &lt;code&gt;lapsSequence&lt;/code&gt; emit an array of split times. From there (after consulting RxExample) was a walk in the park to wire up the table view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//show laps in table
lapsSequence.bindTo(tableView.rx_itemsWithCellIdentifier(&amp;quot;Cell&amp;quot;, cellType: UITableViewCell.self)) { (row, element, cell) in
    cell.textLabel!.text = &amp;quot;\(row+1)) \(element)&amp;quot;
}
.addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And my app was already working!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-table.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Each time I tap the &amp;ldquo;Split Lap&amp;rdquo; button I get a new split time added in the table view. Sweet!&lt;/p&gt;

&lt;h3 id=&#34;5-show-a-table-header-with-the-number-of-laps:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;5 Show a table header with the number of laps&lt;/h3&gt;

&lt;p&gt;This part was the one that tripped me the most. There wasn&amp;rsquo;t a binding I could use for the table header and I didn&amp;rsquo;t want to complicate the code unneccessarily by adding a section table data source.&lt;/p&gt;

&lt;p&gt;What came to mind was to add a &lt;code&gt;UILabel&lt;/code&gt; property to my view controller and use it as the table header view. Then bind the count of split times to the &lt;code&gt;rx_text&lt;/code&gt; of that label.&lt;/p&gt;

&lt;p&gt;So I added to the view controller class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let tableHeaderView = UILabel()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then an extension to set this label as my table view header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension ViewController: UITableViewDelegate {
  func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -&amp;gt; UIView? {
    return tableHeaderView
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I knew how to set my class as the proxy delegate to the table view (back in &lt;code&gt;viewDidLoad&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//set table delegate
tableView
  .rx_setDelegate(self)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now came the coup d&amp;rsquo;etat - I had to map &lt;code&gt;lapsSequence&lt;/code&gt; from an array to a single string (e.g. &amp;ldquo;5 laps&amp;rdquo;) and bind that string to the table header.&lt;/p&gt;

&lt;p&gt;I got overexcited about using &lt;code&gt;scan&lt;/code&gt; but the code did feel itchy so after asking around on the RxSwift slack &lt;a href=&#34;https://twitter.com/KrunoslavZaher&#34;&gt;KrunoslavZaher&lt;/a&gt; enlightened me that since I have one array I can turn it into one string by simply using &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the final code addition to &lt;code&gt;viewDidLoad&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//update the table header
lapsSequence.map({ laps -&amp;gt; String in
    return &amp;quot;\t\(laps.count) laps&amp;quot;
})
.startWith(&amp;quot;\tno laps&amp;quot;)
.bindTo(tableHeaderView.rx_text)
.addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;lapsSequence&lt;/code&gt; emits an array of &lt;em&gt;all&lt;/em&gt; split times each time a new split time is emitted I just take that array and return a string with the number of elements.&lt;/p&gt;

&lt;p&gt;Additionally I set the initial value to &amp;ldquo;no laps&amp;rdquo; and that&amp;rsquo;s pretty much it - I bind everything directly to &lt;code&gt;tableHeaderView.rx_text&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s the complete working app!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-finished.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can download the completed project and give it a try here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer.zip&#34;&gt;rx_laptimer.zip&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>