<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rxcocoa on rx_marin&lt;blog&gt;</title>
    <link>http://rx-marin.com/tags/rxcocoa/</link>
    <description>Recent content in Rxcocoa on rx_marin&lt;blog&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://rx-marin.com/tags/rxcocoa/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>(dotSwift) Search GitHub with RxSwift</title>
      <link>http://rx-marin.com/post/dotswift-search-github-json-api/</link>
      <pubDate>Fri, 27 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/dotswift-search-github-json-api/</guid>
      <description>

&lt;p&gt;In my talk at dotSwift 2017 I start with generic overview of some of the RxSwift basics and move to three complete code examples. In three posts I&amp;rsquo;ll post the sample code and comment shortly why I chose to highlight these exact examples. Let&amp;rsquo;s start with number one.&lt;/p&gt;

&lt;h2 id=&#34;searching-for-github-repositories-with-rxswift:12a67f24277565fb21fc7919261596a9&#34;&gt;Searching for GitHub repositories with RxSwift&lt;/h2&gt;

&lt;p&gt;The first example in the talk is a simple single-screen application that allows the user to enter a repository name (or part of it) and search GitHub for matching results.&lt;/p&gt;

&lt;p&gt;The completed application looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/github-search.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;why-i-chose-this-example:12a67f24277565fb21fc7919261596a9&#34;&gt;Why I chose this example?&lt;/h3&gt;

&lt;p&gt;One of the main points I make in my talk is that Rx and RxSwift in particular solves in big part the pains of asynchronous programming. Cocoa and the iOS SDK offers us a lot of different tools to battle asynchronos flows but there is no standard and we end up using many different (if not all) of these APIs. It&amp;rsquo;s not rare in complex app to use all of NotificationCenter, Grand Central Dispatch, closures, delegates, and more.&lt;/p&gt;

&lt;p&gt;RxSwift solves this by offering a single standard protocol for asynchronous communication between any classes in the app - &lt;code&gt;Observable&lt;/code&gt;. And this is what I wanted to demonstrate with the first example - how a rather diverse workflow that would usually be very complex, involving delegates and closures, becomes very simple to read, and sequential to write.&lt;/p&gt;

&lt;h3 id=&#34;the-sample-code:12a67f24277565fb21fc7919261596a9&#34;&gt;The sample code&lt;/h3&gt;

&lt;p&gt;The example starts with observing the text of a &lt;code&gt;UITextField&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;searchBar.rx.text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The issue with &lt;code&gt;rx.text&lt;/code&gt; is that it emits &lt;code&gt;String?&lt;/code&gt; since the field value is &lt;code&gt;nil&lt;/code&gt; when there&amp;rsquo;s no text inside (Thanks, Obama). Luckily there&amp;rsquo;s an operator called &lt;code&gt;orEmpty&lt;/code&gt;, which converts an optional &lt;code&gt;nil&lt;/code&gt; to unwrapped default value. So for &lt;code&gt;String?&lt;/code&gt; it returns &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; (a non-optional empty string).&lt;/p&gt;

&lt;p&gt;Chained to the previous code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.orEmpty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This maps the observable to &lt;code&gt;Observable&amp;lt;String&amp;gt;&lt;/code&gt;. Neat!&lt;/p&gt;

&lt;p&gt;Next we want to filter search queries too short to be useful that will produce too many and rather irrelevant results. We chain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.filter { query in
  return query.characters.count &amp;gt; 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will discard any searches for less than three characters. Next let&amp;rsquo;s discard any values emitted too fast, we don&amp;rsquo;t need to send all the network requests to GitHub&amp;rsquo;s server on each typed character if the user is typing fast. Chain to the previous code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.debounce(0.5, scheduler: MainScheduler.instance)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user types and then stops for more than half a second, &lt;code&gt;debounce&lt;/code&gt; will let through only the latest value before the user stopped typing. Ok it&amp;rsquo;s time to convert the search query into a web request:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.map { query in
  var apiUrl = URLComponents(string: &amp;quot;https://api.github.com/search/repositories&amp;quot;)!
  apiUrl.queryItems = [URLQueryItem(name: &amp;quot;q&amp;quot;, value: query)]
  return URLRequest(url: apiUrl.url!)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We build a &lt;code&gt;URL&lt;/code&gt; and a &lt;code&gt;URLRequest&lt;/code&gt;, which is ready to be sent to GitHub&amp;rsquo;s server. This &lt;code&gt;map&lt;/code&gt; converts the observable to an &lt;code&gt;Observable&amp;lt;URLRequest&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now by using the built-in reactive extension on &lt;code&gt;URLSession&lt;/code&gt; we can get back the server response in JSON form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.flatMapLatest { request in
  return URLSession.shared.rx.json(request: request)
    .catchErrorJustReturn([])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case there was an error reaching out to the server, &lt;code&gt;catchErrorJustReturn&lt;/code&gt; will make &lt;code&gt;flatMapLatest&lt;/code&gt; return an empty array &lt;code&gt;[]&lt;/code&gt; instead of erroring out. This converts the observable type to &lt;code&gt;Observable&amp;lt;Any&amp;gt;&lt;/code&gt;. So we got the JSON &amp;hellip; What next? Dig inside, find any returned repos and convert the data into objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.map { json -&amp;gt; [Repo] in
  guard let json = json as? [String: Any],
    let items = json[&amp;quot;items&amp;quot;] as? [[String: Any]]  else {
      return []
  }
  return items.flatMap(Repo.init)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;flatMap&lt;/code&gt; on the &lt;code&gt;items&lt;/code&gt; collection will discard any objects that didn&amp;rsquo;t convert propertly to &lt;code&gt;Repo&lt;/code&gt; objects. This final map converts the reponse to an &lt;code&gt;Observable&amp;lt;[Repo]&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We now have the desired outcome - a list of &lt;code&gt;Repo&lt;/code&gt; objects. It&amp;rsquo;s time to show them in the view controller&amp;rsquo;s table view. Using &lt;code&gt;RxCocoa&lt;/code&gt;&amp;rsquo;s &lt;code&gt;bindTo&lt;/code&gt; binding the repos is a matter of few more lines:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.bindTo(tableView.rx.items) { tableView, row, repo in
    let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;Cell&amp;quot;)!
    cell.textLabel!.text = repo.name
    cell.detailTextLabel?.text = repo.language
    return cell
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The operator binds the list of &lt;code&gt;Repo&lt;/code&gt; objects to the table&amp;rsquo;s &lt;code&gt;rx.items&lt;/code&gt;. In the closure parameter you provide the code to deque and configure cells for the table.&lt;/p&gt;

&lt;p&gt;If you want more advanced table binding (e.g. using animations, sections, and more) check out the &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxDataSources&#34;&gt;&lt;code&gt;RxDataSources&lt;/code&gt;&lt;/a&gt; library, which provides many different choices. If you&amp;rsquo;re working with Realm objects, there is a special library that allows you to use row animations and more automatically called &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxRealmDataSources&#34;&gt;&lt;code&gt;RxRealmDataSources&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-complete-example:12a67f24277565fb21fc7919261596a9&#34;&gt;The complete example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;searchBar.rx.text
  .orEmpty
  .filter { query in
    return query.characters.count &amp;gt; 2
  }
  .debounce(0.5, scheduler: MainScheduler.instance)
  .map { query in
    let apiUrl = URL(string: &amp;quot;https://api.github.com/search/repositories?q=&amp;quot; + query)!
    return URLRequest(url: apiUrl)
  }
  .flatMapLatest { request in
    return URLSession.shared.rx.json(request: request)
      .catchErrorJustReturn([])
  }
  .map { json -&amp;gt; [Repo] in
    guard let json = json as? [String: Any],
      let items = json[&amp;quot;items&amp;quot;] as? [[String: Any]]  else {
        return []
    }
    return items.flatMap(Repo.init)
  }
  .bindTo(tableView.rx.items) { tableView, row, repo in
    let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;Cell&amp;quot;)!
    cell.textLabel!.text = repo.name
    cell.detailTextLabel?.text = repo.language
    return cell
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;discussion:12a67f24277565fb21fc7919261596a9&#34;&gt;Discussion&lt;/h3&gt;

&lt;p&gt;In real life you will probably never have the app&amp;rsquo;s logic layed out like this in one single line of code. (You might if you so desire; of course)&lt;/p&gt;

&lt;p&gt;In a full-blown app you will have a networking layer, data layer, etc. You are likely to split this long chain of operators in two or three parts depending on what architecture you use.&lt;/p&gt;

&lt;p&gt;In any case, following the Cocoa patterns you will have one delegate for the text field, one data source for the table, and &lt;code&gt;URLSession&lt;/code&gt; will work with an asynchronous callback closure. The code is split into chunks, and you as the developer need to  always keep in mind the sequence in which these methods will get called as to not corrupt the app state.&lt;/p&gt;

&lt;p&gt;With RxSwift the code is easier to understand because it reads sequentially. Further it&amp;rsquo;s very easy to argue about the order in which code is executed even if it&amp;rsquo;s being executed asynchronously.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Links&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The complete demo app from my talk: &lt;a href=&#34;https://github.com/icanzilb/RxSwiftoniOS&#34;&gt;https://github.com/icanzilb/RxSwiftoniOS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The talk slides: &lt;a href=&#34;https://speakerdeck.com/icanzilb/rxswift-on-ios&#34;&gt;https://speakerdeck.com/icanzilb/rxswift-on-ios&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A smarter Retry with RxSwiftExt</title>
      <link>http://rx-marin.com/post/rxswift-retry-with-delay/</link>
      <pubDate>Sun, 08 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-retry-with-delay/</guid>
      <description>

&lt;p&gt;Sometimes your observable will fail with an error but that would not mean that you need to give up trying. For example saving to a file might fail because the file is locked temporarily but a split second later would be unlocked and ready for your changes. Same goes for web requests - there might be a temporary glitch in connectivity which could make the observable fail.&lt;/p&gt;

&lt;p&gt;RxSwift offers a special operator called &lt;code&gt;retry&lt;/code&gt;, which allows you to try another time the observable subscription upon error.&lt;/p&gt;

&lt;p&gt;You can even tell &lt;code&gt;retry&lt;/code&gt; how many times to keep trying, which is very useful. The code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;responseObservable.retry(3)
  .subscribe(onNext: {next in
    print(&amp;quot;next: \(next)&amp;quot;)
  }, onError: { error in
    print(&amp;quot;error: &amp;quot;)
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case &lt;code&gt;responseObservable&lt;/code&gt; fails, the subscription will &amp;ldquo;&lt;em&gt;restart&lt;/em&gt;&amp;rdquo; up to 3 times and in case it fails all 3 times, it will error out.&lt;/p&gt;

&lt;p&gt;As useful as the built-in operator is - you rarely can solve a real problem by retrying immediately.&lt;/p&gt;

&lt;p&gt;Especially in problems caused by lack of connectivity (and others of course) it&amp;rsquo;s much more useful to wait a little and then retry, hoping that meanwhile the problem was resolved.&lt;/p&gt;

&lt;p&gt;Sometimes it even makes sense to first wait a short interval of time, and after few fails wait longer and longer before retrying.&lt;/p&gt;

&lt;p&gt;There is no built-in &lt;code&gt;retry&lt;/code&gt; operator that will allow you to do that, but you could give a try to &lt;code&gt;RxSwiftExt&lt;/code&gt; - an extra set of operators developed by the community (maintainer of the library is &lt;a href=&#34;https://github.com/fpillet&#34;&gt;fpillet&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;You can have a look at all of the operators included in RxSwiftExt in its README: &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxSwiftExt&#34;&gt;https://github.com/RxSwiftCommunity/RxSwiftExt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After you include (via CocoaPods or Carthage) RxSwiftExt in your project you have few options how to use the smarter &lt;code&gt;retry&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;The smarter &lt;code&gt;retry&lt;/code&gt; takes in a parameter of the &lt;code&gt;RepeatBehavior&lt;/code&gt; enum, which can be one of these four types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;immediate (maxCount:)&lt;/code&gt; - similar to the built-in behavior&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delayed (maxCount:time:)&lt;/code&gt; - retries up to &lt;code&gt;maxCount&lt;/code&gt; times, but with &lt;code&gt;time&lt;/code&gt; amount of seconds between retries&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exponentialDelayed (maxCount:initial:multiplier:)&lt;/code&gt; - retries up to &lt;code&gt;maxCount&lt;/code&gt; times, starts with &lt;code&gt;initial&lt;/code&gt; amount of seconds but uses &lt;code&gt;multiplier&lt;/code&gt; to increase the delay between retries.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;customTimerDelayed(max:delayCalculator:)&lt;/code&gt; - retries up to &lt;code&gt;max&lt;/code&gt; times. &lt;code&gt;delayCalculator&lt;/code&gt; is a closure that gets as input the number of retries so far, and returns how much seconds to wait before trying again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As an extra functionality you can add a closure that evaluates on each retry whether the operator shoud keep trying at all.&lt;/p&gt;

&lt;h3 id=&#34;retrying-at-equal-intervals:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Retrying at equal intervals&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;responseObservable.retry(.delayed(maxCount: 3, time: 5.0),
 shouldRetry: {error in
  return 50..&amp;lt;80 ~= (error as NSError).code
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a more elaborate example so let&amp;rsquo;s have a look. If &lt;code&gt;responseObservable&lt;/code&gt; emits an error &lt;code&gt;retry&lt;/code&gt; will try up to 3 times, with 5 second intervals between the retries.&lt;/p&gt;

&lt;p&gt;Additionally between retries &lt;code&gt;retry&lt;/code&gt; will consult with the &lt;code&gt;shouldRetry&lt;/code&gt; closure if it should keep going. Once the code casts &lt;code&gt;error&lt;/code&gt; as an &lt;code&gt;NSError&lt;/code&gt;, it checks the code of the error. It lets &lt;code&gt;retry&lt;/code&gt; keep trying if the error code is between 50 and 80, and stops retrying if the code is not in that range.&lt;/p&gt;

&lt;p&gt;In your own app return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on your business logic.&lt;/p&gt;

&lt;h3 id=&#34;retrying-in-increasing-intervals:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Retrying in increasing intervals&lt;/h3&gt;

&lt;p&gt;The formula calculting the delay between retries is &lt;code&gt;initial * pow(1 + multiplier, Double(currentRepetition - 1))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;retry(.exponentialDelayed(maxCount: 3, initial: 2.0, multiplier: 1.5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The delay between first and second tries is 2.0 seconds (the value of &lt;code&gt;initial&lt;/code&gt; parameter). Then between second and third tries is 5.0 seconds - &lt;code&gt;2.0 * 2.5&lt;/code&gt; seconds.&lt;/p&gt;

&lt;h3 id=&#34;calculating-the-delay:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Calculating the delay&lt;/h3&gt;

&lt;p&gt;In the end  - if you go for a custom calculator you can simply return any value based on any kind of custom business logic so sky is pretty much the limit.&lt;/p&gt;

&lt;p&gt;As an example here is a piece of code that implements decreasing delays between tries: 10, 9, 8, 7, 6, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let speedUp: (UInt) -&amp;gt; Double = {retries in
  return max(0.0, 10 - Double(retries))
}

responseObservable.retry(.customTimerDelayed(maxCount: 10,
  delayCalculator: speedUp))
    .subscribe()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-non-rxswift-retry:0d2f3d508498ad2374296c16265dc39a&#34;&gt;A non RxSwift retry&lt;/h3&gt;

&lt;p&gt;As a fun bonus, I&amp;rsquo;ve made a &lt;code&gt;retry&lt;/code&gt; library which doesn&amp;rsquo;t use RxSwift at all as I find a custom-delay &lt;code&gt;retry&lt;/code&gt; very useful in all kinds of apps. You can use the pure Swift &lt;code&gt;retry&lt;/code&gt; in a very similar manner: &lt;a href=&#34;https://github.com/icanzilb/retry&#34;&gt;https://github.com/icanzilb/retry&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Implementing state with scan in RxSwift</title>
      <link>http://rx-marin.com/post/rxswift-state-with-scan/</link>
      <pubDate>Mon, 04 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-state-with-scan/</guid>
      <description>

&lt;h2 id=&#34;intro:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Common misconception is that you cannot have state with Rx. Well you can - and there&amp;rsquo;s a special operator that helps you to: &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve ever used &lt;code&gt;reduce&lt;/code&gt; in Swift - scan is a very similar operator but &lt;code&gt;reduce&lt;/code&gt; goes over the complete sequence and gives you the final value of the accumulator while &lt;code&gt;scan&lt;/code&gt; emits each intermediate value as well.&lt;/p&gt;

&lt;p&gt;If you haven&amp;rsquo;t used &lt;code&gt;reduce&lt;/code&gt; - no worries you&amp;rsquo;ll get to understand &lt;code&gt;scan&lt;/code&gt; from the examples below. Let&amp;rsquo;s get started!&lt;/p&gt;

&lt;h2 id=&#34;creating-a-boolean-switch:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Creating a boolean switch&lt;/h2&gt;

&lt;p&gt;When you have to deal with UI you inevitably have to deal with state. Imagine a button that toggles between selected and deselected state as the user taps it repeatedly. One tap - the button is selected, another tap - it&amp;rsquo;s not, a third taps selects it again, etc.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;UIButton.rx_tap&lt;/code&gt; always emits the same value of &lt;code&gt;Void&lt;/code&gt; so it doesn&amp;rsquo;t provide you with any information to decide whether to select or deselect the button. Enter &lt;code&gt;scan&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; takes two parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;initial value - you can think of it as the first value of your state&lt;/li&gt;
&lt;li&gt;closure(lastState, newValue) - &lt;code&gt;scan&lt;/code&gt; runs that closure each time it gets a new value - it calls it with two parameters: the last state you had and the value that was just emitted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You might wander what the state is? Anything you want it to be (I know&amp;hellip; clichés) - it can be a &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, an &lt;code&gt;Array&lt;/code&gt; anything you need for your code. Let&amp;rsquo;s look at the first example to make everything click together.&lt;/p&gt;

&lt;p&gt;I had to make button get selected/deselected as described earlier so I used &lt;code&gt;scan&lt;/code&gt; in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(false) { lastState, newValue in
    return !lastState
}
.subscribeNext {value in
    print(&amp;quot;tap: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all consider how the &lt;code&gt;scan&lt;/code&gt; above transforms the data stream. It starts with &lt;code&gt;Void&lt;/code&gt; values emitted by &lt;code&gt;rx_tap&lt;/code&gt; but then scan maps those to &lt;code&gt;Bool&lt;/code&gt; values (determined by the type of its &lt;code&gt;return&lt;/code&gt; type):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(tap) &amp;mdash;&amp;gt; Void &amp;mdash;&amp;gt; (scan) &amp;mdash;&amp;gt; Bool &amp;mdash;&amp;gt; (subscribeNext)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So scan starts with a &lt;code&gt;false&lt;/code&gt; state and on each button tap it applies the closure. The first time &lt;code&gt;lastState = false&lt;/code&gt; and &lt;code&gt;newValue = Void&lt;/code&gt; (actually &lt;code&gt;newValue&lt;/code&gt; is always &lt;code&gt;Void&lt;/code&gt; so I&amp;rsquo;ll ignore till the end of this example). You return the negation of &lt;code&gt;lastState&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second time around &lt;code&gt;lastState&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; because this is what you return the first time. And your return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Third time around &lt;code&gt;lastState&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and you return &lt;code&gt;true&lt;/code&gt;. Etc. etc. etc.&lt;/p&gt;

&lt;p&gt;The console output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tap: true
tap: false
tap: true
tap: false
tap: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So as you can see you can implement state but it&amp;rsquo;s contained within the closure you supply to &lt;code&gt;scan&lt;/code&gt;. After &lt;code&gt;scan&lt;/code&gt; you get a data stream of the type your closure returns - that&amp;rsquo;s all :)&lt;/p&gt;

&lt;p&gt;So to complete the select/deselect example you just need to bind the &lt;code&gt;scan&lt;/code&gt; result to your button&amp;rsquo;s &lt;code&gt;rx_selected&lt;/code&gt; sink like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(false) { lastState, newValue in
    return !lastState
}
.bindTo(myButton.rx_selected)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-a-counter:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Creating a counter&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s get beyond alternating between &lt;code&gt;Bool&lt;/code&gt; values and write a code to count how many times a button has been tapped.&lt;/p&gt;

&lt;p&gt;I actually had to do this few times in the last couple months so I&amp;rsquo;ll just put in here the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(0) { lastCount, newValue in
    return lastCount + 1
}
.subscribeNext {value in
    print(&amp;quot;taps: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time around the state is of type &lt;code&gt;Int&lt;/code&gt; and it starts with &lt;code&gt;0&lt;/code&gt;. Each time the user taps the button &lt;code&gt;scan&lt;/code&gt; returns the last count plus 1. As the user taps the button the Console shows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;taps: 1
taps: 2
taps: 3
taps: 4
taps: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you grasp how the last state thing works it&amp;rsquo;s pretty easy isn&amp;rsquo;t it? :)&lt;/p&gt;

&lt;h2 id=&#34;geting-the-last-n-values:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Geting the last N values&lt;/h2&gt;

&lt;p&gt;Somebody in the RxSwift Slack asked for this and it&amp;rsquo;s an interesting (but very simple to solve) example.&lt;/p&gt;

&lt;p&gt;How to get the last N elements from an Observable?&lt;/p&gt;

&lt;p&gt;For example if you have a sequence of &lt;code&gt;Int&lt;/code&gt; values: &lt;code&gt;[0, 1, 2, 3, 4, 5, 6]&lt;/code&gt; how to have the last 3 each time a new value is emitted?&lt;/p&gt;

&lt;p&gt;Well, this smells like having a state since you need to &amp;ldquo;&lt;em&gt;remember&lt;/em&gt;&amp;rdquo; values. So it must be solvable with &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Obviously the first time the sequence emits you don&amp;rsquo;t have any previous values so the initial state to give to &lt;code&gt;scan&lt;/code&gt; is an empty array &lt;code&gt;[]&lt;/code&gt;. Let&amp;rsquo;s have a look at the complete code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let numbers = [0, 1, 2 , 3, 4, 5, 6].toObservable()

numbers.scan([]) { lastSlice, newValue in
    return Array(lastSlice + [newValue]).suffix(3)
}
.subscribeNext {value in
    print(&amp;quot;last 3: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time &lt;code&gt;scan&lt;/code&gt; adds the emitted value to the last array you had and than chops 3 elements off the end. Now the data stream looks like so:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(numbers) &amp;mdash;&amp;gt; Int &amp;mdash;&amp;gt; (scan) &amp;mdash;&amp;gt; [Int] &amp;mdash;&amp;gt; subscribeNext&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And the Console output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;last 3: [0]
last 3: [0, 1]
last 3: [0, 1, 2]
last 3: [1, 2, 3]
last 3: [2, 3, 4]
last 3: [3, 4, 5]
last 3: [4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But didn&amp;rsquo;t I say I wanted elements of three? Just &lt;code&gt;filter&lt;/code&gt; the output of &lt;code&gt;scan&lt;/code&gt; and check for the length of the emitted array and that&amp;rsquo;s it ;)&lt;/p&gt;

&lt;h2 id=&#34;using-enums-for-state:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Using enums for state&lt;/h2&gt;

&lt;p&gt;I didn&amp;rsquo;t have to do any more advanced &lt;code&gt;scan&lt;/code&gt; stuff yet but I can imagine all kinds of uses for it. Let&amp;rsquo;s say you&amp;rsquo;re building a space game.&lt;/p&gt;

&lt;p&gt;When you start a level in your space game your ship has to make it through an asteroid field. Therefore the longer the ship is &amp;ldquo;alive&amp;rdquo; the more points you get, etc.&lt;/p&gt;

&lt;p&gt;So you can build a timer that tracks the level time and bind the level state and the amount of points earned like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum LevelState {
    case Normal, PowerUp
}

let timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.25, scheduler: MainScheduler.instance)

timer.scan((LevelState.Normal, 0)) { lastState, _ in
    
    switch lastState.0 {
    case .Normal:
        if lastState.1 &amp;gt; 1000 {
            return (.PowerUp, lastState.1 + 30)
        } else {
            return (.Normal, lastState.1 + 30)
        }
    case .PowerUp:
        return (.PowerUp, lastState.1 + 100)
    }
}
.subscribeNext {_, points in
    print(&amp;quot;pts: \(points)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You have two states in your level - normal mode and power-up. Once the player manages to survive past 1,000 points they start gaining more points much faster. To do that you have two states listed in an enum &lt;code&gt;LevelState&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The state is a tuple of type &lt;code&gt;(LevelState, Int)&lt;/code&gt; - the first element tracks the current level state, and second is the points counter.&lt;/p&gt;

&lt;p&gt;And this is still a pretty simple example of what is possible with &lt;code&gt;scan&lt;/code&gt; and few lines of code. Woot!&lt;/p&gt;

&lt;p&gt;Look those numbers fly once you&amp;rsquo;re past the &lt;code&gt;1,000&lt;/code&gt; mark!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pts: 810
pts: 840
pts: 870
pts: 900
pts: 930
pts: 960
pts: 990
pts: 1020
pts: 1050
pts: 1150
pts: 1250
pts: 1350
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; is simply fantastic and as I wrote in an earlier post - any time you&amp;rsquo;re tempted to use &lt;code&gt;reduce&lt;/code&gt; you probably need &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I hope that post has been useful and if you have any operator that bums you out or can&amp;rsquo;t figure out ping me on Twitter - I&amp;rsquo;m also still learning but have few of those figured out pretty well :)&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom bindings with RxSwift</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-custom-bindings/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-custom-bindings/</guid>
      <description>

&lt;h2 id=&#34;intro:d4dcb38b814640de6df8a9df2675e24b&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;After I did some convenience operators of my own, which really made things easier while writing code I thought I&amp;rsquo;d be a good idea to look into building more stuff on my own.&lt;/p&gt;

&lt;p&gt;It helps learning and it&amp;rsquo;s healthy :)&lt;/p&gt;

&lt;h2 id=&#34;binding-to-make-a-view-visible:d4dcb38b814640de6df8a9df2675e24b&#34;&gt;Binding to make a view visible&lt;/h2&gt;

&lt;p&gt;I noticed there is a binding on the &lt;code&gt;hidden&lt;/code&gt; property of &lt;code&gt;UIView&lt;/code&gt; but sometimes the code just reads better when you don&amp;rsquo;t have to think of &lt;em&gt;hiding something&lt;/em&gt; but rather &lt;strong&gt;showing something&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So I thought since I can check out the source code for &lt;code&gt;rx_hidden&lt;/code&gt; how hard could it be to make my own &lt;code&gt;rx_visible&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;So I just copied over the code and made my first bindable sink:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension UIView {
    public var rx_visible: AnyObserver&amp;lt;Bool&amp;gt; {
        return UIBindingObserver(UIElement: self) { view, visible in
            view.hidden = !visible
        }.asObserver()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I know that isn&amp;rsquo;t a great departure from &lt;code&gt;rx_hidden&lt;/code&gt; but sometimes it really makes more sense (and it&amp;rsquo;s more readable) to use &lt;code&gt;rx_visible&lt;/code&gt;. Let&amp;rsquo;s look:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;//longer, logic is reversed
isEnabled.map {enabled in !enabled}.bindTo(messageView.rx_hidden)

//short and sweet
isEnabled.bindTo(messageView.rx_visible)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really like the latter a bit better! So far so good :)&lt;/p&gt;

&lt;h2 id=&#34;binding-for-becoming-and-resigning-first-responder:d4dcb38b814640de6df8a9df2675e24b&#34;&gt;Binding for becoming and resigning first responder&lt;/h2&gt;

&lt;p&gt;Next - I felt like building something that would actually add functionality it isn&amp;rsquo;t already in.&lt;/p&gt;

&lt;p&gt;In the project I&amp;rsquo;m currently working on I have a search bar and I have few buttons that show and hide the search bar depending on what the user wants to do.&lt;/p&gt;

&lt;p&gt;Therefore I thought it&amp;rsquo;d be great to make my own bindable sink for being a first responder.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension UIResponder {
    public var rx_firstResponder: AnyObserver&amp;lt;Bool&amp;gt; {
        return UIBindingObserver(UIElement: self) {control, shouldRespond in
            shouldRespond ? control.becomeFirstResponder() : control.resignFirstResponder()
        }.asObserver()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example isn&amp;rsquo;t more complex than the previous one. It&amp;rsquo;s a bindable &lt;code&gt;Bool&lt;/code&gt; property, which either makes the control become or resign first responder.&lt;/p&gt;

&lt;p&gt;Now I could group the show and hide buttons into one observable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let searchBarActive = [btnSearch.rx_tap.replaceWith(true), searchBarBtnCancel.replaceWith(false)].toObservable()
  .merge()
  .startWith(false)
  .shareReplay(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And besides all the other changes in the UI make the search bar active or force it to lose focus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;searchBarActive.bindTo(searchController.searchBar.rx_firstResponder)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neat! Since I started writing rx code I&amp;rsquo;ve really grown to dislike having &lt;code&gt;if&lt;/code&gt; operators (also &lt;code&gt;var&lt;/code&gt; but that&amp;rsquo;s a whole other story)&lt;/p&gt;

&lt;h2 id=&#34;conclusion:d4dcb38b814640de6df8a9df2675e24b&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Okay so creating simple on-the-fly cocoa bindings is easy. But is it worth it if it&amp;rsquo;s so easy?&lt;/p&gt;

&lt;p&gt;I like bindings better than writing code to update the UI. No &lt;code&gt;if&lt;/code&gt; and no closures to update the UI - no problem. I know other people prefer to not use RxCocoa at all and just use RxSwift and update the UI themselves.&lt;/p&gt;

&lt;p&gt;I guess either is okay :)&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom convenience operators with RxSwift, Part 2</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part2/</link>
      <pubDate>Mon, 07 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part2/</guid>
      <description>

&lt;h2 id=&#34;intro:46ffa07f8102997fe7674832bad6bc33&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;I got some great feedback on last week&amp;rsquo;s post on convenience operators &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part1/&#34;&gt;part 1&lt;/a&gt; so I&amp;rsquo;m really excited to publish part 2, which I hope will be even more interesting for those of you who are looking into RxSwift.&lt;/p&gt;

&lt;p&gt;Without further ado let&amp;rsquo;s dive in code&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;a-better-negate-operator:46ffa07f8102997fe7674832bad6bc33&#34;&gt;A better negate() operator&lt;/h2&gt;

&lt;p&gt;First of all I have a better version of my &lt;code&gt;negate()&lt;/code&gt; operator from last week for you. What I wrote on my own was a pretty simple function that looked like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: BooleanType {
  public func negate() -&amp;gt; Observable&amp;lt;Bool&amp;gt; {
     return map {value in !value}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It doesn&amp;rsquo;t get simpler than that, right? You map a value in a single line of code and that&amp;rsquo;s it (careful, it&amp;rsquo;s a trick question).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tailec.com/&#34;&gt;@tailec&lt;/a&gt; grabbed me in Slack and showed me his version of the same operator, which definitely beats mine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: BooleanType {
    public func negate() -&amp;gt; Observable&amp;lt;Bool&amp;gt; {
        return map(!)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yup! Since &lt;code&gt;!&lt;/code&gt; is a function with a single parameter you can simply use in conjunction with &lt;code&gt;map&lt;/code&gt; as shown above. That code definitely looks better than mine and I&amp;rsquo;m gonna be using this version in my own projects too. Thanks &lt;a href=&#34;https://twitter.com/tailectailec&#34;&gt;Pawel&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Please guys, if you see something I&amp;rsquo;m posting here that can be improved get in touch, like Pawel did, and help get some awesome rx code out together!&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;filternegatives:46ffa07f8102997fe7674832bad6bc33&#34;&gt;filterNegatives()&lt;/h2&gt;

&lt;p&gt;I was looking over my current project&amp;rsquo;s code and trying to identify repeating patterns I can easily &lt;em&gt;outsource&lt;/em&gt; to a convenience operator.&lt;/p&gt;

&lt;p&gt;I noticed I have few &lt;code&gt;Bool&lt;/code&gt; observables that I am sometimes interested in only if they were emitting &lt;code&gt;true&lt;/code&gt; value. For example if we take the code from my &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/&#34;&gt;lap timer post&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let isRunning = [btnPlay.rx_tap.replaceWith(true), btnStop.rx_tap.replaceWith(false)]
  .toObservable()
  .merge()
  .startWith(false)
  .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which produces depending on taps on the play and stop buttons:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;true &amp;mdash; false &amp;mdash; true &amp;mdash; true &amp;ndash;&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How about observing only the taps on play? (Except just subscribing to the play button of course)&lt;/p&gt;

&lt;p&gt;Since what I wanted was to basically get rid of the all &lt;code&gt;false&lt;/code&gt; values I wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: BooleanType {
  public func filterNegatives() -&amp;gt; Observable&amp;lt;Bool&amp;gt; {
     return map {value in value.boolValue}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty easy piece of code, it does the work well and it&amp;rsquo;s clear to read. Great!&lt;/p&gt;

&lt;h2 id=&#34;replacenilwith:46ffa07f8102997fe7674832bad6bc33&#34;&gt;replaceNilWith(_)&lt;/h2&gt;

&lt;p&gt;This was an easy operator to implement. I had a couple of observables emitting optional values and I actually wanted to get a given &lt;em&gt;default&lt;/em&gt; value instead of &lt;code&gt;nil&lt;/code&gt;. I just had to map to a simple condition that checks for a &lt;code&gt;nil&lt;/code&gt; value like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable {
  func replaceNilWith(value: Element) -&amp;gt; Observable&amp;lt;Element&amp;gt; {
     return map {element in element == nil ? value : element}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the elements of the observable are still of type &lt;code&gt;Optional&amp;lt;Element&amp;gt;&lt;/code&gt; but you just never get a &lt;code&gt;nil&lt;/code&gt; value - you get your default value instead.&lt;/p&gt;

&lt;h2 id=&#34;filterout:46ffa07f8102997fe7674832bad6bc33&#34;&gt;filterOut(_)&lt;/h2&gt;

&lt;p&gt;While I was having a lot of momentum I decided to also write a filter that gets rid of specific values. Since the approach is exactly the same as before I&amp;rsquo;ll just add the code here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: Equatable {
    public func filterOut(targetValue: Element) -&amp;gt; Observable&amp;lt;Element&amp;gt; {
        return self.filter {value in targetValue != value}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting aspect about this piece of code is that to be able to identify the offending value in your sequence it needs to be &lt;code&gt;Equatable&lt;/code&gt; so you have to restrict the &lt;code&gt;filterOut&lt;/code&gt; operator to only observables that emit &lt;code&gt;Equatable&lt;/code&gt; elements.&lt;/p&gt;

&lt;p&gt;This of course is a walk in the park in Swift where you can just add &lt;code&gt;where Element: Equatable&lt;/code&gt; on your extension.&lt;/p&gt;

&lt;p&gt;The best thing about &lt;code&gt;filterOut(_)&lt;/code&gt; is that whenever I have an observable emitting optional values like for example &lt;code&gt;Observable&amp;lt;Bool?&amp;gt;&lt;/code&gt;, I can ensure no &lt;code&gt;nil&lt;/code&gt; values are emitted like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;optionalBoolSequence.filterOut(nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The observable elements are still of type &lt;code&gt;Optional&amp;lt;Bool&amp;gt;&lt;/code&gt; but now I am sure that the observable never emits a &lt;code&gt;nil&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;And leads me to &amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;unwrap:46ffa07f8102997fe7674832bad6bc33&#34;&gt;unwrap(_)&lt;/h2&gt;

&lt;p&gt;At that point I had two convenience operators to get rid of &lt;code&gt;nil&lt;/code&gt;s in my observables but the elements were still &lt;code&gt;Optional&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Well, I thought, it could not be so hard to actually unwrap the elements of an &lt;code&gt;Observable&lt;/code&gt; with all the Swift protocols black magic and such!&lt;/p&gt;

&lt;p&gt;Boy, was I &lt;strong&gt;totally&lt;/strong&gt; and &lt;strong&gt;completely&lt;/strong&gt; wrong&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/fry-wrong.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;My first realization was that &lt;code&gt;Optional&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; a protocol. Thus I couldn&amp;rsquo;t do any protocol black magic with it. Ugh!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; is actually an enum. Yes - this sounded pretty exciting when Swift 1.0 alpha was out, but honestly right now I&amp;rsquo;d expect that it was a protocol or something more flexible.&lt;/p&gt;

&lt;p&gt;Anywho, since &lt;code&gt;Optional&lt;/code&gt; isn&amp;rsquo;t a protocol I couldn&amp;rsquo;t create an extension on &lt;code&gt;Observable&lt;/code&gt; that matches optional elements. Gulp.&lt;/p&gt;

&lt;p&gt;I had a long long conversation with &lt;a href=&#34;https://twitter.com/mhollemans&#34;&gt;Matthijs&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/narrativium&#34;&gt;Ross O&amp;rsquo;Brien&lt;/a&gt; in Slack until in the end I could figure out the way&amp;hellip;&lt;/p&gt;

&lt;p&gt;First of all I had to define a protocol for optionals myself. My protocol had to define two methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;one that checks if the current value is &lt;code&gt;nil&lt;/code&gt; (guess what - simply comparing &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; didn&amp;rsquo;t really work, yay!)&lt;/li&gt;
&lt;li&gt;another that unwraps &lt;code&gt;self&lt;/code&gt; from &lt;code&gt;Optional&amp;lt;Type&amp;gt;&lt;/code&gt; to &lt;code&gt;Type&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The big question that I had to wrap my mind around was: What type is the unwrapped value? I didn&amp;rsquo;t know that in my protocol so I had to define a type that the concrete implementations would set.&lt;/p&gt;

&lt;p&gt;I ended up with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol Optionable
{
  typealias WrappedType
  func unwrap() -&amp;gt; WrappedType
  func isEmpty() -&amp;gt; Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool - I had a protocol which I could use to add a method to &lt;code&gt;Observable&lt;/code&gt; via an extension.&lt;/p&gt;

&lt;p&gt;But first I had to make the &lt;code&gt;Optional&lt;/code&gt; enum to conform to &lt;code&gt;Optionable&lt;/code&gt;. So &lt;code&gt;Optional&lt;/code&gt; exposes the type of the wrapped value via &lt;code&gt;Wrapped&lt;/code&gt; and that&amp;rsquo;s where the magic fusion between &lt;code&gt;Optional&lt;/code&gt; and my &lt;code&gt;Optionable&lt;/code&gt; protocol happened.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the declaration of &lt;code&gt;Optional&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum Optional&amp;lt;Wrapped&amp;gt; : _Reflectable, NilLiteralConvertible {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s how I wired &lt;code&gt;Optionable&lt;/code&gt; to to the type of any concrete optional value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Optional : Optionable
{
    typealias WrappedType = Wrapped
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha! &lt;em&gt;(Again Matthijs and Ross helped a lot along the way of untangling all of this. I must say that there is very little info online about protocol magic and associated types.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now I could also add the implementation of the two methods in the extension:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func unwrap() -&amp;gt; WrappedType {
    return self!
}

func isEmpty() -&amp;gt; Bool {
    return !(flatMap({_ in true})?.boolValue == true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You guessed it - coding &lt;code&gt;unwrap()&lt;/code&gt; was pretty straight forward, but &lt;code&gt;isEmpty()&lt;/code&gt; caused me serious headache.&lt;/p&gt;

&lt;p&gt;To my surprise (repeating myself here I know), &lt;code&gt;Optional&lt;/code&gt; doesn&amp;rsquo;t give you means to check whether it&amp;rsquo;s empty or not.&lt;/p&gt;

&lt;p&gt;At first I came with this naïve implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func isEmpty() -&amp;gt; Bool {
  switch self {
    case .None: return false
    case .Some(_): return true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, let me tell you: this doesn&amp;rsquo;t work. Although if you ask me it should. But it doesn&amp;rsquo;t - it never falls in the &lt;code&gt;case .None&lt;/code&gt; branch for some reason and is beyond me why.&lt;/p&gt;

&lt;p&gt;So I had to take the hard way, I looked again through everything I can find in an &lt;code&gt;Optional&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/optional-docs.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not much. Not much &amp;hellip;&lt;/p&gt;

&lt;p&gt;Wait! &lt;code&gt;flatMap&lt;/code&gt;? But of course! Here&amp;rsquo;s the (complete) docs on Optional&amp;rsquo;s flatMap:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Returns nil if self is nil, f(self!) otherwise.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I rewrote my &lt;code&gt;isEmpty()&lt;/code&gt; method to use &lt;code&gt;flatMap&lt;/code&gt; and I was off to the races:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func isEmpty() -&amp;gt; Bool {
    return !(flatMap({_ in true})?.boolValue == true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now (&lt;em&gt;finally&lt;/em&gt;) I could get to adding the extension to &lt;code&gt;Observable&lt;/code&gt;. Compared to all the rest I&amp;rsquo;ve been through this was &amp;hellip; let&amp;rsquo;s say &lt;em&gt;not so difficult&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element : Optionable {
  func unwrap() -&amp;gt; Observable&amp;lt;Element.WrappedType&amp;gt; {
    return self
      .filter {value in
        return !value.isEmpty()
      }
      .map {value -&amp;gt; Element.WrappedType in
        value.unwrap()
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notable mentions about that piece of code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;m matching the Observable type to &lt;code&gt;Optionable&lt;/code&gt;. &lt;code&gt;Optional&lt;/code&gt; implements &lt;code&gt;Optionable&lt;/code&gt; but if any other type does that &lt;code&gt;unwrap()&lt;/code&gt; will work for it too&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unwrap()&lt;/code&gt; takes in an &lt;code&gt;Element&lt;/code&gt; value and outputs &lt;code&gt;Element.WrappedType&lt;/code&gt;, so for &lt;code&gt;Int?&lt;/code&gt; outputs &lt;code&gt;Int&lt;/code&gt;, for &lt;code&gt;NSDate?&lt;/code&gt; outputs &lt;code&gt;NSDate&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;why not use &lt;code&gt;filterOut(nil)&lt;/code&gt; to get rid of the &lt;code&gt;nil&lt;/code&gt; values? &lt;code&gt;filterOut(_)&lt;/code&gt; works for &lt;code&gt;Equatable&lt;/code&gt; values and &lt;code&gt;Element.WrappedType&lt;/code&gt; might not be &lt;code&gt;Equatable&lt;/code&gt; in some cases&lt;/li&gt;
&lt;li&gt;I had to explicitly set the return type for my &lt;code&gt;map&lt;/code&gt; closure because Xcode thought things were getting a bit too abstract for it&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now let&amp;rsquo;s see the complete implementation (and if you can think of ways to simplify this please let me know, I still think there should be an easier way):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol Optionable
{
  typealias WrappedType
  func unwrap() -&amp;gt; WrappedType
  func isEmpty() -&amp;gt; Bool
}

extension Optional : Optionable
{
  typealias WrappedType = Wrapped
  func unwrap() -&amp;gt; WrappedType {
    return self!
  }
    
  func isEmpty() -&amp;gt; Bool {
    return !(flatMap({_ in true})?.boolValue == true)
  }
}

extension Observable where Element : Optionable {
  func unwrap() -&amp;gt; Observable&amp;lt;Element.WrappedType&amp;gt; {
    return self
      .filter {value in
        return !value.isEmpty()
      }
      .map {value -&amp;gt; Element.WrappedType in
        value.unwrap()
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well that was a fun day! To be fair I also learned quite a lot about protocols, associated types, etc.&lt;/p&gt;

&lt;p&gt;Later on I was talking to &lt;a href=&#34;https://twitter.com/fpillet&#34;&gt;@fpillet&lt;/a&gt; who shared this piece here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;someOptionalSequence
  .flatMap { $0 == nil ? Observable.empty() : Observable.just($0!) }`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s a one liner you can use directly on your Observable of &lt;code&gt;Optional&amp;lt;Element&amp;gt;&lt;/code&gt; type. It does pretty much the same as my &lt;code&gt;unwrap()&lt;/code&gt; operator but it&amp;rsquo;s way shorter because the &lt;code&gt;flatMap&lt;/code&gt; closure doesn&amp;rsquo;t need to specify its return type - it leaves it to Xcode to figure it out out of context.&lt;/p&gt;

&lt;p&gt;I still like my own operator though - I think it&amp;rsquo;s much more readable and it adds less stress to the compiler to write just:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;someOptionalSequence.unwrap()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/unwrap-doge.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:46ffa07f8102997fe7674832bad6bc33&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Creating your own convenience operators is awesome. The code is more readable, there is less opportunity to introduce bugs, and there&amp;rsquo;s nothing wrong with it.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m already planning the next post: creating your own Cocoa bindings. If you have done some cool custom bindings for UIKit classes, or any other interesting bindable properties let me know. Woot!&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom convenience operators with RxSwift, Part 1</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part1/</link>
      <pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part1/</guid>
      <description>

&lt;h2 id=&#34;intro:00ee3dba4704e83677ebf533fee4350e&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Just like when learning a new language you need to build up a dictionary to start understanding how the language works, you got to learn the Rx operators and everything will eventually click together.&lt;/p&gt;

&lt;p&gt;And then once you have a good common of a language it&amp;rsquo;s okay to start coming up with new words too to boost the expressiveness of your speech and for convenience.&lt;/p&gt;

&lt;p&gt;Same thing happened with me last week - for the first time I felt like I&amp;rsquo;m getting work done with RxSwift because I had good understanding how to use at least few operators. Naturally I wished to create my own custom convenience operators that would not do anything essentially new but will just help me express myself better and clearer.&lt;/p&gt;

&lt;h2 id=&#34;replacewith-value-replace-any-element-with-a-constant:00ee3dba4704e83677ebf533fee4350e&#34;&gt;replaceWith(value): Replace any element with a constant&lt;/h2&gt;

&lt;p&gt;When I just want to react to a certain group of events I replace the actual value emitted so that I can merge two or more Observables into one stream and observe that single stream.&lt;/p&gt;

&lt;p&gt;The following piece of code is from &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/&#34;&gt;last weeks&lt;/a&gt; post and observes the taps on the Start and Stop buttons of the laps timer app:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let isRunning = [btnPlay.rx_tap.map({_ in true}), btnStop.rx_tap.map({_ in false})]
	.toObservable()
    .merge()
    .startWith(false)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was looking at this chunk of code and thought that there should be a cleaner, more readable way to represent the mapping parts. What I do there for both observables is to ignore the actual value and replace it with a constant.&lt;/p&gt;

&lt;p&gt;So I dug through the RxSwift code and based on what I found there I put together this brilliant (hic) piece of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func replaceWith&amp;lt;R&amp;gt;(value: R) -&amp;gt; Observable&amp;lt;R&amp;gt; {
    return Observable.create { observer in
        let subscription = self.subscribe { e in
            switch e {
            case .Next(_):
                observer.on(.Next(value))
            case .Error(let error):
                observer.on(.Error(error))
            case .Completed:
                observer.on(.Completed)
            }
        }
        return subscription
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I create and return a new &lt;code&gt;Observable&lt;/code&gt; and pass through the &lt;code&gt;Error&lt;/code&gt; and &lt;code&gt;Completed&lt;/code&gt; events, but replace the value of the &lt;code&gt;Next&lt;/code&gt; event with the &lt;code&gt;value&lt;/code&gt; constant. Seems good?&lt;/p&gt;

&lt;p&gt;What looked like a magnificent piece of code turned out to be a bit of an overkill. I mean after all I just wanted to &amp;ldquo;map&amp;rdquo; any value of any type to a constant and when you say it that way the code almost writes itself! So in the end I rewrote the code like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension ObservableType {
    func replaceWith&amp;lt;R&amp;gt;(value: R) -&amp;gt; Observable&amp;lt;R&amp;gt; {
        return map { _ in value }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see I didn&amp;rsquo;t have to go crazy about the whole thing but just literally take the piece of code I wanted to re-use and abstract it in a method on the &lt;code&gt;ObservableType&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With this the same code block from the beginning of the post looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let isRunning = [btnPlay.rx_tap.replaceWith(true), btnStop.rx_tap.replaceWith(false)]
	.toObservable()
    .merge()
    .startWith(false)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! Having my own custom convenience operator made the code less prone to errors (no custom code in a closure to write) and more readable.&lt;/p&gt;

&lt;p&gt;At this point I started doubting myself a bit - this was too good to be true honestly. I thought I must be doing something wrong :)&lt;/p&gt;

&lt;p&gt;However it turned out many people have this exact custom operator in their code base, it apparently solves a common problem.&lt;/p&gt;

&lt;p&gt;Then I got a bit crazy and decided just for fun to explore how much further I can take this.&lt;/p&gt;

&lt;h2 id=&#34;replacewithdate-replace-with-timestamp-of-the-latest-value:00ee3dba4704e83677ebf533fee4350e&#34;&gt;replaceWithDate(): Replace with timestamp of the latest value&lt;/h2&gt;

&lt;p&gt;Since I was already warmed up by putting together &lt;code&gt;replaceWith&lt;/code&gt; I thought it&amp;rsquo;d be fun to have a convenience operator to give me the timestamp of the latest element from the observable sequence.&lt;/p&gt;

&lt;p&gt;In this concrete case the constant I&amp;rsquo;d replace the element with would just be the current date:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension ObservableType {
    func replaceWithDate&amp;lt;R&amp;gt;(value: R) -&amp;gt; Observable&amp;lt;NSDate&amp;gt; {
        return map { _ in NSDate() }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can bind the latest value from an Observable to a label, and show the timestamp of that value in another label like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let count = Observable&amp;lt;Int&amp;gt;
    .interval(3, scheduler: MainScheduler.instance)
    .shareReplay(1)

count.map {counter in &amp;quot;\(counter)&amp;quot;}
    .bindTo(label1.rx_text)
    .addDisposableTo(bag)

count.replaceWithDate()
    .map {$0.description}
    .bindTo(label2.rx_text)
    .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the result (wait few seconds to see the increments):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/latest-date.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;negate-negate-the-value-of-the-element:00ee3dba4704e83677ebf533fee4350e&#34;&gt;negate(): Negate the value of the element&lt;/h2&gt;

&lt;p&gt;Next I noticed that sometimes I need to bind an &lt;code&gt;Observable&lt;/code&gt; to &lt;code&gt;rx_enabled&lt;/code&gt; property of a button, and sometimes to &lt;code&gt;rx_hidden&lt;/code&gt;. While writing binding code I had to use numerous &lt;code&gt;map {value in !value}&lt;/code&gt;, which made my code less readable.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you check &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/&#34;&gt;last week&amp;rsquo;s post&lt;/a&gt; you will see that in my effort to increase readability I ended up having two observables: one called &lt;code&gt;isRunning&lt;/code&gt; and one &lt;code&gt;isntRunning&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After another read through some of RxSwift&amp;rsquo;s code I learned how to add an operator to an &lt;code&gt;Observable&lt;/code&gt; of a certain type. In my case I wanted to add the &lt;code&gt;negate()&lt;/code&gt; operator to just observables producing &lt;code&gt;Bool&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Observable&lt;/code&gt; exposes its elements&amp;rsquo; type as &lt;code&gt;Element&lt;/code&gt; and I could easily match this to the &lt;code&gt;BooleanType&lt;/code&gt; (Swift ftw!):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: BooleanType {
    public func negate() -&amp;gt; Observable&amp;lt;Bool&amp;gt; {
        return map {value in !value}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sweet - thanks protocol extensions with associated types! Now I could easily write code like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;active.bindTo(btnStart.rx_enabled).addDisposableTo(bag)
active.negate().bindTo(btnStart.rx_hidden).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will both enable and show the button whenever &lt;code&gt;active&lt;/code&gt; emits a &lt;code&gt;true&lt;/code&gt; element. Pretty sleek eh?&lt;/p&gt;

&lt;p&gt;To wrap up today&amp;rsquo;s post here&amp;rsquo;s what I&amp;rsquo;ve also added to my project a bit later:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element : SignedIntegerType {
    public func negate() -&amp;gt; Observable&amp;lt;E&amp;gt; {
        return map {value in -value}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;negate()&lt;/code&gt; worked also in other contexts. If you used it on &lt;code&gt;Observable&amp;lt;Bool&amp;gt;&lt;/code&gt; it would apply a logical &lt;code&gt;not&lt;/code&gt; to the value; if you used it on a &lt;code&gt;Observable&amp;lt;Int&amp;gt;&lt;/code&gt; it would produce the negative value of the element. Cool!&lt;/p&gt;

&lt;h2 id=&#34;conclusion:00ee3dba4704e83677ebf533fee4350e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Creating your own convenience operators is awesome. The code is more readable, there is less opportunity to introduce bugs, and there&amp;rsquo;s nothing wrong with it.&lt;/p&gt;

&lt;p&gt;In my next post I&amp;rsquo;ll look into few more operators I created along the way for myself. Do you want to share any of yours?&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on  Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Split laps timer with RxSwift and RxCocoa: Part 2</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/</guid>
      <description>&lt;p&gt;In my post from last week I worked on creating a split lapse timer app (&lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/&#34;&gt;last week&amp;rsquo;s post&lt;/a&gt;). But later on when I was playing with the application I noticed that I naturally would like to have means to start or stop the timer.&lt;/p&gt;

&lt;p&gt;Well this week I am implementing exactly this functionality.&lt;/p&gt;

&lt;p&gt;The first thing I thought about was how to implement state in my app because a timer clearly has two distinct states either running or not running. That got me thinking about combining signals, mapping, you know, all the good stuff.&lt;/p&gt;

&lt;p&gt;If you want to follow along you can download the starter project I prepared. It is in the shape where last weeks blog posts leaves off but I&amp;rsquo;ve added a couple of buttons in the user interface:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/latimer-new-ui.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Download the starter project to follow along here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer_starter.zip&#34;&gt;rx_laptimer_starter.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s put all those buttons to work!&lt;/p&gt;

&lt;p&gt;My very first idea was to try generating a sequence of values to describe the current state of the timer. The start button would produce &lt;code&gt;true&lt;/code&gt; values and the stop button will produce &lt;code&gt;false&lt;/code&gt; values. When merged I will get one sequence that emits every time the state changes:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;o---- (play tap) true--- (stop tap) false --- (play tap) true ---&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So at the top of &lt;code&gt;viewDidLoad()&lt;/code&gt; I created a new Observable like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isRunning = [btnPlay.rx_tap.map({_ in true}), btnStop.rx_tap.map({_ in false})]
    .toObservable()
    .merge()
    .startWith(false)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I mapped the taps on &lt;code&gt;btnPlay&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; and the taps on &lt;code&gt;btnStop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; and merged them together.&lt;/p&gt;

&lt;p&gt;The Observable starts with a &lt;code&gt;false&lt;/code&gt; value to give the user the opportunity to start the timer at their convenience.&lt;/p&gt;

&lt;p&gt;I printed the values the new observable emits and was quite happy with the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;isRunning.subscribeNext({state in
    print(state)
}).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code printed &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; in the console each time I pressed play or stop. Neato!&lt;/p&gt;

&lt;p&gt;Now it looked very easy to bind that Observable to the buttons&amp;rsquo; &lt;code&gt;rx_enabled&lt;/code&gt; property to actually make the UI reflect the timer state. I could as well hide the laps button when the timer isn&amp;rsquo;t running at all!&lt;/p&gt;

&lt;p&gt;And since some of the controls needed to be enabled when the timer is running and others when it isn&amp;rsquo;t - I made myself yet another observable and bound the controls like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isntRunning = isRunning.map({running in !running}).shareReplay(1)

isRunning.bindTo(btnStop.rx_enabled).addDisposableTo(bag)
isntRunning.bindTo(btnLap.rx_hidden).addDisposableTo(bag)
isntRunning.bindTo(btnPlay.rx_enabled).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The stop button is enabled while the timer is running. Play is enabled when the timer is paused.&lt;/p&gt;

&lt;p&gt;I really love this kind of code. No &lt;code&gt;if&lt;/code&gt;s no &lt;code&gt;switch&lt;/code&gt;es; once you get the code running it&amp;rsquo;s very difficult to mess up and there&amp;rsquo;s simply no space for introducing bugs. Everything is air-tight.&lt;/p&gt;

&lt;p&gt;The app started with the laps button hidden and only the play button enabled like so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-play.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Further you could click play just once because it instantly became disabled. How cool :]&lt;/p&gt;

&lt;p&gt;Now my problem was that even though the UI already reflected the different states of the timer - well &amp;hellip; the timer didn&amp;rsquo;t care at all about any of that :]&lt;/p&gt;

&lt;p&gt;I looked into the &lt;code&gt;RxSwift&lt;/code&gt; implementation of a timer but didn&amp;rsquo;t find a way how to pause it (I guess that it couldn&amp;rsquo;t implement state, who knows &amp;hellip;). That&amp;rsquo;s why I thought I&amp;rsquo;d move away from directly binding the timer to the UI and implement my own counter.&lt;/p&gt;

&lt;p&gt;At the time my timer looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, I thought, I just need to somehow combine &lt;code&gt;isRunning&lt;/code&gt; and &lt;code&gt;timer&lt;/code&gt; and filter the observable output when &lt;code&gt;isRunning&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So I did the following: I appended to the existing &lt;code&gt;timer&lt;/code&gt; an operator to combine it with the latest value from &lt;code&gt;isRunning&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.withLatestFrom(isRunning, resultSelector: {_, running in running})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You see that I just ignored the value emitted by &lt;code&gt;timer&lt;/code&gt; since I never use it for anything and return from &lt;code&gt;withLatestFrom&lt;/code&gt; the unchanged &lt;code&gt;running&lt;/code&gt; input parameter:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(Int, Boolean) -&amp;gt; withLatestFrom -&amp;gt; Boolean&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Next I could simply use &lt;code&gt;filter&lt;/code&gt; to stop the observable from emitting when the timer is not running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.filter({running in running})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And last but not least I had to attach a counter, but that was already something I knew how to do with &lt;code&gt;scan&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.scan(0, accumulator: {(acc, _) in
    return acc+1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What &lt;code&gt;scan&lt;/code&gt; does above is to count how many times the timer fired while &lt;code&gt;isRunning&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; (which is exactly what I wanted).&lt;/p&gt;

&lt;p&gt;Finally I had to set the initial value to show in the UI and to share the result between all observers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; .startWith(0)
 .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete code of the enhanced timer observable looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)
    .withLatestFrom(isRunning, resultSelector: {_, running in running})
    .filter({running in running})
    .scan(0, accumulator: {(acc, _) in
        return acc+1
    })
    .startWith(0)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s a wrap :] Now my timer app had a stateful UI and split lap all implemented without a single &lt;code&gt;if&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-2-final.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can get the completed project from here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer_finished.zip&#34;&gt;rx_laptimer_finished.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on  Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Split laps timer with RxSwift and RxCocoa</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/</link>
      <pubDate>Tue, 16 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/</guid>
      <description>

&lt;p&gt;I was browsing through &lt;a href=&#34;http://rxmarbles.com/&#34;&gt;RxMarbles&lt;/a&gt; and was totally baffled by the &lt;code&gt;sample&lt;/code&gt; function. The marble diagram looks pretty random at first sight:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/marbles-sample.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At first I thought - &amp;ldquo;Hey, that second sequence is getting totally ignored!&amp;rdquo;. But after I read the description I figured it out:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The first sequence&amp;rsquo;s elements is &lt;strong&gt;what&lt;/strong&gt; &lt;code&gt;sample&lt;/code&gt; emits, while the second sequence&amp;rsquo;s elements determine &lt;strong&gt;when&lt;/strong&gt; &lt;code&gt;sample&lt;/code&gt; emits. So in a way yes - the actual values A, B, C, D do get totally ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When it was clear to me what &lt;code&gt;sample&lt;/code&gt; does I started wondering if this function has any practical application :]&lt;/p&gt;

&lt;p&gt;This brought me to creating a split lap timer app to test what &lt;code&gt;sample&lt;/code&gt; can do for me. In the finished project I have a timer emitting time values (aka the first sequence) and I want to grab (or sample) the values whenever the user taps a button (aka the second sequence).&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the marble diagram looks like for the app setup:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/sample-dia.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this is how the app looks like when finished:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-finished.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s build that app :]&lt;/p&gt;

&lt;p&gt;Here are the specs I wanted for my split lap timer app:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;start the timer at launch&lt;/li&gt;
&lt;li&gt;show the running time in format MM:SS.MS&lt;/li&gt;
&lt;li&gt;when the user taps &amp;ldquo;Split Lap&amp;rdquo; add a split time&lt;/li&gt;
&lt;li&gt;show a table of the split times&lt;/li&gt;
&lt;li&gt;show a table head with the total of laps&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-start-a-timer:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;1 Start a timer&lt;/h3&gt;

&lt;p&gt;Like in my &lt;a href=&#34;http://rx-marin.com/post/rxswift-timer-sequence-manual-dispose-bag/&#34;&gt;previous post&lt;/a&gt; about manually disposing bag&amp;rsquo;s contents I added a timer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var timer: Observable&amp;lt;NSInteger&amp;gt;!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in &lt;code&gt;viewDidLoad&lt;/code&gt; let it run every &lt;code&gt;1/10&lt;/code&gt; of a second (I chose to show only 1 digit for milliseconds so no need to fire more often):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//create the timer
timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)

timer.subscribeNext({ msecs -&amp;gt; Void in
  print(&amp;quot;\(msecs)00ms&amp;quot;)
}).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This got the timer running and filling up the console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;000ms
100ms
200ms
300ms
400ms
500ms
600ms
700ms
800ms
900ms
1000ms
1100ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool - that was easy (well, I already knew how to do that part, lol)&lt;/p&gt;

&lt;h3 id=&#34;2-show-the-current-elapsed-time:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;2 Show the current elapsed time&lt;/h3&gt;

&lt;p&gt;This was also a part I already knew how to do. First I put together a little function to take the elapsed time and return a nicely formatted string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func stringFromTimeInterval(ms: NSInteger) -&amp;gt; String {
  return String(format: &amp;quot;%0.2d:%0.2d.%0.1d&amp;quot;,
    arguments: [(ms / 600) % 600, (ms % 600 ) / 10, ms % 10])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then back in &lt;code&gt;viewDidLoad&lt;/code&gt; I used it to bind the timer to a label I added via Interface Builder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//wire the chrono
timer.map(stringFromTimeInterval)
  .bindTo(lblChrono.rx_text)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really love how the code flows and tells the story of what should happen:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;timer -&amp;gt; 1,2,3 -&amp;gt; stringFromTimeInterval -&amp;gt; &amp;quot;string&amp;quot;, &amp;quot;string&amp;quot; -&amp;gt; lblChrono&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Functional code is awesome because I get 2 huge wins for free: I can easily reuse &lt;code&gt;stringFromTimeInterval&lt;/code&gt; and I can write very simple tests for it.&lt;/p&gt;

&lt;p&gt;At this point the timer label already displayed the elapsed time:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-label.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-grab-the-split-time-when-the-user-taps-the-split-lap-button:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;3 Grab the split time when the user taps the &amp;ldquo;Split Lap&amp;rdquo; button&lt;/h3&gt;

&lt;p&gt;Ok here I was supposed to have my ultimate win by using &lt;code&gt;sample&lt;/code&gt;. The first few tries didn&amp;rsquo;t get me far until I realized that the &lt;code&gt;rx_tap&lt;/code&gt; property on &lt;code&gt;UIButton&lt;/code&gt; is also an &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Duh, everything is an &lt;code&gt;Observable&lt;/code&gt; :]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then it was just a matter of calling &lt;code&gt;sample&lt;/code&gt; on my timer and providing as a control sequence the &lt;code&gt;rx_tap&lt;/code&gt; property of the button like so: &lt;code&gt;timer.sample(btnLap.rx_tap)&lt;/code&gt; Whaaaat?&lt;/p&gt;

&lt;p&gt;Now each time I tapped the button &lt;code&gt;sample&lt;/code&gt; emitted the latest value produced by &lt;code&gt;timer&lt;/code&gt;. And since I wasn&amp;rsquo;t interested in the number but in the formatted string I again mapped the result with &lt;code&gt;stringFromTimeInterval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And since I needed to build a list of those split times I used &lt;code&gt;scan&lt;/code&gt;. Actually at first I came around &lt;code&gt;reduce&lt;/code&gt; because I was thinking of accumulating values in a list, but then realized I needed to produce a sequence that emits the list for each new value&amp;hellip; hence I kind of knew I got to use &lt;code&gt;scan&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let lapsSequence = timer.sample(btnLap.rx_tap)
    .map(stringFromTimeInterval)
    .scan([String](), accumulator: {lapTimes, newTime in
        return lapTimes + [newTime]
    })
    .shareReplay(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So - each time &lt;code&gt;sample&lt;/code&gt; emits a new lap time &lt;code&gt;scan&lt;/code&gt; emits an array of all the split times so far.&lt;/p&gt;

&lt;p&gt;Not sure how to explain &lt;code&gt;scan&lt;/code&gt; more simply but I&amp;rsquo;ll try: In RxSwift any time you&amp;rsquo;re thinking of using &lt;code&gt;reduce&lt;/code&gt; chances are you need &lt;code&gt;scan&lt;/code&gt; instead :]&lt;/p&gt;

&lt;h3 id=&#34;4-show-a-table-of-the-split-times-so-far:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;4 Show a table of the split times so far&lt;/h3&gt;

&lt;p&gt;Ok so I got &lt;code&gt;lapsSequence&lt;/code&gt; emit an array of split times. From there (after consulting RxExample) was a walk in the park to wire up the table view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//show laps in table
lapsSequence.bindTo(tableView.rx_itemsWithCellIdentifier(&amp;quot;Cell&amp;quot;, cellType: UITableViewCell.self)) { (row, element, cell) in
    cell.textLabel!.text = &amp;quot;\(row+1)) \(element)&amp;quot;
}
.addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And my app was already working!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-table.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Each time I tap the &amp;ldquo;Split Lap&amp;rdquo; button I get a new split time added in the table view. Sweet!&lt;/p&gt;

&lt;h3 id=&#34;5-show-a-table-header-with-the-number-of-laps:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;5 Show a table header with the number of laps&lt;/h3&gt;

&lt;p&gt;This part was the one that tripped me the most. There wasn&amp;rsquo;t a binding I could use for the table header and I didn&amp;rsquo;t want to complicate the code unneccessarily by adding a section table data source.&lt;/p&gt;

&lt;p&gt;What came to mind was to add a &lt;code&gt;UILabel&lt;/code&gt; property to my view controller and use it as the table header view. Then bind the count of split times to the &lt;code&gt;rx_text&lt;/code&gt; of that label.&lt;/p&gt;

&lt;p&gt;So I added to the view controller class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let tableHeaderView = UILabel()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then an extension to set this label as my table view header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension ViewController: UITableViewDelegate {
  func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -&amp;gt; UIView? {
    return tableHeaderView
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I knew how to set my class as the proxy delegate to the table view (back in &lt;code&gt;viewDidLoad&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//set table delegate
tableView
  .rx_setDelegate(self)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now came the coup d&amp;rsquo;etat - I had to map &lt;code&gt;lapsSequence&lt;/code&gt; from an array to a single string (e.g. &amp;ldquo;5 laps&amp;rdquo;) and bind that string to the table header.&lt;/p&gt;

&lt;p&gt;I got overexcited about using &lt;code&gt;scan&lt;/code&gt; but the code did feel itchy so after asking around on the RxSwift slack &lt;a href=&#34;https://twitter.com/KrunoslavZaher&#34;&gt;KrunoslavZaher&lt;/a&gt; enlightened me that since I have one array I can turn it into one string by simply using &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the final code addition to &lt;code&gt;viewDidLoad&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//update the table header
lapsSequence.map({ laps -&amp;gt; String in
    return &amp;quot;\t\(laps.count) laps&amp;quot;
})
.startWith(&amp;quot;\tno laps&amp;quot;)
.bindTo(tableHeaderView.rx_text)
.addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;lapsSequence&lt;/code&gt; emits an array of &lt;em&gt;all&lt;/em&gt; split times each time a new split time is emitted I just take that array and return a string with the number of elements.&lt;/p&gt;

&lt;p&gt;Additionally I set the initial value to &amp;ldquo;no laps&amp;rdquo; and that&amp;rsquo;s pretty much it - I bind everything directly to &lt;code&gt;tableHeaderView.rx_text&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s the complete working app!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-finished.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can download the completed project and give it a try here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer.zip&#34;&gt;rx_laptimer.zip&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>