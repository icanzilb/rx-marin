<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>State on rx_marin&lt;blog&gt;</title>
    <link>http://rx-marin.com/tags/state/</link>
    <description>Recent content in State on rx_marin&lt;blog&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://rx-marin.com/tags/state/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Implementing state with scan in RxSwift</title>
      <link>http://rx-marin.com/post/rxswift-state-with-scan/</link>
      <pubDate>Mon, 04 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-state-with-scan/</guid>
      <description>

&lt;h2 id=&#34;intro:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Common misconception is that you cannot have state with Rx. Well you can - and there&amp;rsquo;s a special operator that helps you to: &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve ever used &lt;code&gt;reduce&lt;/code&gt; in Swift - scan is a very similar operator but &lt;code&gt;reduce&lt;/code&gt; goes over the complete sequence and gives you the final value of the accumulator while &lt;code&gt;scan&lt;/code&gt; emits each intermediate value as well.&lt;/p&gt;

&lt;p&gt;If you haven&amp;rsquo;t used &lt;code&gt;reduce&lt;/code&gt; - no worries you&amp;rsquo;ll get to understand &lt;code&gt;scan&lt;/code&gt; from the examples below. Let&amp;rsquo;s get started!&lt;/p&gt;

&lt;h2 id=&#34;creating-a-boolean-switch:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Creating a boolean switch&lt;/h2&gt;

&lt;p&gt;When you have to deal with UI you inevitably have to deal with state. Imagine a button that toggles between selected and deselected state as the user taps it repeatedly. One tap - the button is selected, another tap - it&amp;rsquo;s not, a third taps selects it again, etc.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;UIButton.rx_tap&lt;/code&gt; always emits the same value of &lt;code&gt;Void&lt;/code&gt; so it doesn&amp;rsquo;t provide you with any information to decide whether to select or deselect the button. Enter &lt;code&gt;scan&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; takes two parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;initial value - you can think of it as the first value of your state&lt;/li&gt;
&lt;li&gt;closure(lastState, newValue) - &lt;code&gt;scan&lt;/code&gt; runs that closure each time it gets a new value - it calls it with two parameters: the last state you had and the value that was just emitted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You might wander what the state is? Anything you want it to be (I know&amp;hellip; clich√©s) - it can be a &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, an &lt;code&gt;Array&lt;/code&gt; anything you need for your code. Let&amp;rsquo;s look at the first example to make everything click together.&lt;/p&gt;

&lt;p&gt;I had to make button get selected/deselected as described earlier so I used &lt;code&gt;scan&lt;/code&gt; in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(false) { lastState, newValue in
    return !lastState
}
.subscribeNext {value in
    print(&amp;quot;tap: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all consider how the &lt;code&gt;scan&lt;/code&gt; above transforms the data stream. It starts with &lt;code&gt;Void&lt;/code&gt; values emitted by &lt;code&gt;rx_tap&lt;/code&gt; but then scan maps those to &lt;code&gt;Bool&lt;/code&gt; values (determined by the type of its &lt;code&gt;return&lt;/code&gt; type):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(tap) &amp;mdash;&amp;gt; Void &amp;mdash;&amp;gt; (scan) &amp;mdash;&amp;gt; Bool &amp;mdash;&amp;gt; (subscribeNext)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So scan starts with a &lt;code&gt;false&lt;/code&gt; state and on each button tap it applies the closure. The first time &lt;code&gt;lastState = false&lt;/code&gt; and &lt;code&gt;newValue = Void&lt;/code&gt; (actually &lt;code&gt;newValue&lt;/code&gt; is always &lt;code&gt;Void&lt;/code&gt; so I&amp;rsquo;ll ignore till the end of this example). You return the negation of &lt;code&gt;lastState&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second time around &lt;code&gt;lastState&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; because this is what you return the first time. And your return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Third time around &lt;code&gt;lastState&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and you return &lt;code&gt;true&lt;/code&gt;. Etc. etc. etc.&lt;/p&gt;

&lt;p&gt;The console output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tap: true
tap: false
tap: true
tap: false
tap: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So as you can see you can implement state but it&amp;rsquo;s contained within the closure you supply to &lt;code&gt;scan&lt;/code&gt;. After &lt;code&gt;scan&lt;/code&gt; you get a data stream of the type your closure returns - that&amp;rsquo;s all :)&lt;/p&gt;

&lt;p&gt;So to complete the select/deselect example you just need to bind the &lt;code&gt;scan&lt;/code&gt; result to your button&amp;rsquo;s &lt;code&gt;rx_selected&lt;/code&gt; sink like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(false) { lastState, newValue in
    return !lastState
}
.bindTo(myButton.rx_selected)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-a-counter:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Creating a counter&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s get beyond alternating between &lt;code&gt;Bool&lt;/code&gt; values and write a code to count how many times a button has been tapped.&lt;/p&gt;

&lt;p&gt;I actually had to do this few times in the last couple months so I&amp;rsquo;ll just put in here the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(0) { lastCount, newValue in
    return lastCount + 1
}
.subscribeNext {value in
    print(&amp;quot;taps: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time around the state is of type &lt;code&gt;Int&lt;/code&gt; and it starts with &lt;code&gt;0&lt;/code&gt;. Each time the user taps the button &lt;code&gt;scan&lt;/code&gt; returns the last count plus 1. As the user taps the button the Console shows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;taps: 1
taps: 2
taps: 3
taps: 4
taps: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you grasp how the last state thing works it&amp;rsquo;s pretty easy isn&amp;rsquo;t it? :)&lt;/p&gt;

&lt;h2 id=&#34;geting-the-last-n-values:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Geting the last N values&lt;/h2&gt;

&lt;p&gt;Somebody in the RxSwift Slack asked for this and it&amp;rsquo;s an interesting (but very simple to solve) example.&lt;/p&gt;

&lt;p&gt;How to get the last N elements from an Observable?&lt;/p&gt;

&lt;p&gt;For example if you have a sequence of &lt;code&gt;Int&lt;/code&gt; values: &lt;code&gt;[0, 1, 2, 3, 4, 5, 6]&lt;/code&gt; how to have the last 3 each time a new value is emitted?&lt;/p&gt;

&lt;p&gt;Well, this smells like having a state since you need to &amp;ldquo;&lt;em&gt;remember&lt;/em&gt;&amp;rdquo; values. So it must be solvable with &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Obviously the first time the sequence emits you don&amp;rsquo;t have any previous values so the initial state to give to &lt;code&gt;scan&lt;/code&gt; is an empty array &lt;code&gt;[]&lt;/code&gt;. Let&amp;rsquo;s have a look at the complete code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let numbers = [0, 1, 2 , 3, 4, 5, 6].toObservable()

numbers.scan([]) { lastSlice, newValue in
    return Array(lastSlice + [newValue]).suffix(3)
}
.subscribeNext {value in
    print(&amp;quot;last 3: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time &lt;code&gt;scan&lt;/code&gt; adds the emitted value to the last array you had and than chops 3 elements off the end. Now the data stream looks like so:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(numbers) &amp;mdash;&amp;gt; Int &amp;mdash;&amp;gt; (scan) &amp;mdash;&amp;gt; [Int] &amp;mdash;&amp;gt; subscribeNext&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And the Console output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;last 3: [0]
last 3: [0, 1]
last 3: [0, 1, 2]
last 3: [1, 2, 3]
last 3: [2, 3, 4]
last 3: [3, 4, 5]
last 3: [4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But didn&amp;rsquo;t I say I wanted elements of three? Just &lt;code&gt;filter&lt;/code&gt; the output of &lt;code&gt;scan&lt;/code&gt; and check for the length of the emitted array and that&amp;rsquo;s it ;)&lt;/p&gt;

&lt;h2 id=&#34;using-enums-for-state:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Using enums for state&lt;/h2&gt;

&lt;p&gt;I didn&amp;rsquo;t have to do any more advanced &lt;code&gt;scan&lt;/code&gt; stuff yet but I can imagine all kinds of uses for it. Let&amp;rsquo;s say you&amp;rsquo;re building a space game.&lt;/p&gt;

&lt;p&gt;When you start a level in your space game your ship has to make it through an asteroid field. Therefore the longer the ship is &amp;ldquo;alive&amp;rdquo; the more points you get, etc.&lt;/p&gt;

&lt;p&gt;So you can build a timer that tracks the level time and bind the level state and the amount of points earned like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum LevelState {
    case Normal, PowerUp
}

let timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.25, scheduler: MainScheduler.instance)

timer.scan((LevelState.Normal, 0)) { lastState, _ in
    
    switch lastState.0 {
    case .Normal:
        if lastState.1 &amp;gt; 1000 {
            return (.PowerUp, lastState.1 + 30)
        } else {
            return (.Normal, lastState.1 + 30)
        }
    case .PowerUp:
        return (.PowerUp, lastState.1 + 100)
    }
}
.subscribeNext {_, points in
    print(&amp;quot;pts: \(points)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You have two states in your level - normal mode and power-up. Once the player manages to survive past 1,000 points they start gaining more points much faster. To do that you have two states listed in an enum &lt;code&gt;LevelState&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The state is a tuple of type &lt;code&gt;(LevelState, Int)&lt;/code&gt; - the first element tracks the current level state, and second is the points counter.&lt;/p&gt;

&lt;p&gt;And this is still a pretty simple example of what is possible with &lt;code&gt;scan&lt;/code&gt; and few lines of code. Woot!&lt;/p&gt;

&lt;p&gt;Look those numbers fly once you&amp;rsquo;re past the &lt;code&gt;1,000&lt;/code&gt; mark!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pts: 810
pts: 840
pts: 870
pts: 900
pts: 930
pts: 960
pts: 990
pts: 1020
pts: 1050
pts: 1150
pts: 1250
pts: 1350
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; is simply fantastic and as I wrote in an earlier post - any time you&amp;rsquo;re tempted to use &lt;code&gt;reduce&lt;/code&gt; you probably need &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I hope that post has been useful and if you have any operator that bums you out or can&amp;rsquo;t figure out ping me on Twitter - I&amp;rsquo;m also still learning but have few of those figured out pretty well :)&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on Twitter.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>