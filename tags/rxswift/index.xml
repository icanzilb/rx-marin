<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rxswift on rx_marin&lt;blog&gt;</title>
    <link>http://rx-marin.com/tags/rxswift/</link>
    <description>Recent content in Rxswift on rx_marin&lt;blog&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 08 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://rx-marin.com/tags/rxswift/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A smarter Retry with RxSwiftExt</title>
      <link>http://rx-marin.com/post/rxswift-retry-with-delay/</link>
      <pubDate>Sun, 08 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-retry-with-delay/</guid>
      <description>

&lt;p&gt;Sometimes your observable will fail with an error but that would not mean that you need to give up trying. For example saving to a file might fail because the file is locked temporarily but a split second later would be unlocked and ready for your changes. Same goes for web requests - there might be a temporary glitch in connectivity which could make the observable fail.&lt;/p&gt;

&lt;p&gt;RxSwift offers a special operator called &lt;code&gt;retry&lt;/code&gt;, which allows you to try another time the observable subscription upon error.&lt;/p&gt;

&lt;p&gt;You can even tell &lt;code&gt;retry&lt;/code&gt; how many times to keep trying, which is very useful. The code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;responseObservable.retry(3)
  .subscribe(onNext: {next in
    print(&amp;quot;next: \(next)&amp;quot;)
  }, onError: { error in
    print(&amp;quot;error: &amp;quot;)
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case &lt;code&gt;responseObservable&lt;/code&gt; fails, the subscription will &amp;ldquo;&lt;em&gt;restart&lt;/em&gt;&amp;rdquo; up to 3 times and in case it fails all 3 times, it will error out.&lt;/p&gt;

&lt;p&gt;As useful as the built-in operator is - you rarely can solve a real problem by retrying immediately.&lt;/p&gt;

&lt;p&gt;Especially in problems caused by lack of connectivity (and others of course) it&amp;rsquo;s much more useful to wait a little and then retry, hoping that meanwhile the problem was resolved.&lt;/p&gt;

&lt;p&gt;Sometimes it even makes sense to first wait a short interval of time, and after few fails wait longer and longer before retrying.&lt;/p&gt;

&lt;p&gt;There is no built-in &lt;code&gt;retry&lt;/code&gt; operator that will allow you to do that, but you could give a try to &lt;code&gt;RxSwiftExt&lt;/code&gt; - an extra set of operators developed by the community (maintainer of the library is &lt;a href=&#34;https://github.com/fpillet&#34;&gt;fpillet&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;You can have a look at all of the operators included in RxSwiftExt in its README: &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxSwiftExt&#34;&gt;https://github.com/RxSwiftCommunity/RxSwiftExt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After you include (via CocoaPods or Carthage) RxSwiftExt in your project you have few options how to use the smarter &lt;code&gt;retry&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;The smarter &lt;code&gt;retry&lt;/code&gt; takes in a parameter of the &lt;code&gt;RepeatBehavior&lt;/code&gt; enum, which can be one of these four types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;immediate (maxCount:)&lt;/code&gt; - similar to the built-in behavior&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delayed (maxCount:time:)&lt;/code&gt; - retries up to &lt;code&gt;maxCount&lt;/code&gt; times, but with &lt;code&gt;time&lt;/code&gt; amount of seconds between retries&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exponentialDelayed (maxCount:initial:multiplier:)&lt;/code&gt; - retries up to &lt;code&gt;maxCount&lt;/code&gt; times, starts with &lt;code&gt;initial&lt;/code&gt; amount of seconds but uses &lt;code&gt;multiplier&lt;/code&gt; to increase the delay between retries.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;customTimerDelayed(max:delayCalculator:)&lt;/code&gt; - retries up to &lt;code&gt;max&lt;/code&gt; times. &lt;code&gt;delayCalculator&lt;/code&gt; is a closure that gets as input the number of retries so far, and returns how much seconds to wait before trying again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As an extra functionality you can add a closure that evaluates on each retry whether the operator shoud keep trying at all.&lt;/p&gt;

&lt;h3 id=&#34;retrying-at-equal-intervals:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Retrying at equal intervals&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;responseObservable.retry(.delayed(maxCount: 3, time: 5.0),
 shouldRetry: {error in
  return 50..&amp;lt;80 ~= (error as NSError).code
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a more elaborate example so let&amp;rsquo;s have a look. If &lt;code&gt;responseObservable&lt;/code&gt; emits an error &lt;code&gt;retry&lt;/code&gt; will try up to 3 times, with 5 second intervals between the retries.&lt;/p&gt;

&lt;p&gt;Additionally between retries &lt;code&gt;retry&lt;/code&gt; will consult with the &lt;code&gt;shouldRetry&lt;/code&gt; closure if it should keep going. Once the code casts &lt;code&gt;error&lt;/code&gt; as an &lt;code&gt;NSError&lt;/code&gt;, it checks the code of the error. It lets &lt;code&gt;retry&lt;/code&gt; keep trying if the error code is between 50 and 80, and stops retrying if the code is not in that range.&lt;/p&gt;

&lt;p&gt;In your own app return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on your business logic.&lt;/p&gt;

&lt;h3 id=&#34;retrying-in-increasing-intervals:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Retrying in increasing intervals&lt;/h3&gt;

&lt;p&gt;The formula calculting the delay between retries is &lt;code&gt;initial * pow(1 + multiplier, Double(currentRepetition - 1))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;retry(.exponentialDelayed(maxCount: 3, initial: 2.0, multiplier: 1.5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The delay between first and second tries is 2.0 seconds (the value of &lt;code&gt;initial&lt;/code&gt; parameter). Then between second and third tries is 5.0 seconds - &lt;code&gt;2.0 * 2.5&lt;/code&gt; seconds.&lt;/p&gt;

&lt;h3 id=&#34;calculating-the-delay:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Calculating the delay&lt;/h3&gt;

&lt;p&gt;In the end  - if you go for a custom calculator you can simply return any value based on any kind of custom business logic so sky is pretty much the limit.&lt;/p&gt;

&lt;p&gt;As an example here is a piece of code that implements decreasing delays between tries: 10, 9, 8, 7, 6, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let speedUp: (UInt) -&amp;gt; Double = {retries in
  return max(0.0, 10 - Double(retries))
}

responseObservable.retry(.customTimerDelayed(maxCount: 10,
  delayCalculator: speedUp))
    .subscribe()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-non-rxswift-retry:0d2f3d508498ad2374296c16265dc39a&#34;&gt;A non RxSwift retry&lt;/h3&gt;

&lt;p&gt;As a fun bonus, I&amp;rsquo;ve made a &lt;code&gt;retry&lt;/code&gt; library which doesn&amp;rsquo;t use RxSwift at all as I find a custom-delay &lt;code&gt;retry&lt;/code&gt; very useful in all kinds of apps. You can use the pure Swift &lt;code&gt;retry&lt;/code&gt; in a very similar manner: &lt;a href=&#34;https://github.com/icanzilb/retry&#34;&gt;https://github.com/icanzilb/retry&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hope that post was helpful, and if you want to get in touch you can find me here &lt;a href=&#34;https://twitter.com/icanzilb&#34;&gt;https://twitter.com/icanzilb&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing your RxSwift code, part 2</title>
      <link>http://rx-marin.com/post/rxswift-rxtests-unit-tests-part-2/</link>
      <pubDate>Mon, 23 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxtests-unit-tests-part-2/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxtests-unit-tests/&#34;&gt;part 1&lt;/a&gt; I looked into writing very basic tests with RxSwift and life was good. But then I wanted to do more and moved on to writing asynchronous tests&amp;hellip;&lt;/p&gt;

&lt;p&gt;I contributed the code for RxRealm - the Rx extension for RealmSwift owned by the RxSwiftCommunity. For RxRealm I needed some asynchronous tests because Realm&amp;rsquo;s collections emit notifications (which RxRealm wraps) when the underlaying data changes.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look at some of the unit tests I wrote&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;asynchronous-tests:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Asynchronous tests&lt;/h2&gt;

&lt;p&gt;First of all I needed to look into writing asynchronous tests - luckily this is quite easy. The basic structure of such a test is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testSomething() {
  let expectation1 = expectationWithDescription(&amp;quot;First event&amp;quot;)
  let expectation2 = expectationWithDescription(&amp;quot;Second event&amp;quot;)

  ... whatever code you need to perform the test ... 
  
  someAsyncAPI(didComplete: {
    expectation1.fulfill()
  })

  someOtherAsyncAPI(didComplete: {
    expectation2.fulfill()
  })
  
  waitForExpectationsWithTimeout(1.0) {error in
     XCTAssertTrue(error == nil)
     ... more asserts ... 
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at what this code does:
 * you need to define all the expectations you&amp;rsquo;d like this test to wait for before it completes; the string argument is decorative,
 * whenever the events you are waiting for complete you call &lt;code&gt;fulfill()&lt;/code&gt; on your expectations,
 * finally you need to define a block to be executed when &lt;strong&gt;ALL&lt;/strong&gt; the expectations are fulfilled; &lt;code&gt;waitForExpectationsWithTimeout&lt;/code&gt; &amp;rsquo;s first parameter is a timeout, which will force the block to execute if the expectations do not fulfill in time.&lt;/p&gt;

&lt;h2 id=&#34;combine-testscheduler-and-async-tests:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Combine TestScheduler and async tests&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s look at a complete test from the RxRealm test suite.&lt;/p&gt;

&lt;p&gt;First I start by defining a single expectation - my expectation will be that a precise number of events were emitted by the observable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;    
func testResultsTypeChangeset() {
    let expectation1 = expectationWithDescription(&amp;quot;Results&amp;quot;)

    let realm = realmInMemory(#function)
    clearRealm(realm)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally I use two of my helper methods to grab a reference to an in-memory realm and clear all objects that might&amp;rsquo;ve been stored inside by other tests in the suite.&lt;/p&gt;

&lt;p&gt;Now just like in Part 1 I define a dispose bag and a test scheduler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let bag = DisposeBag()
        
let scheduler = TestScheduler(initialClock: 0)
let observer = scheduler.createObserver(String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I&amp;rsquo;ll be observing a sequence of &lt;code&gt;String&lt;/code&gt;s - you&amp;rsquo;ll see why in a minute.&lt;/p&gt;

&lt;h2 id=&#34;fulfilling-expectations:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Fulfilling expectations&lt;/h2&gt;

&lt;p&gt;Next I need to create a &lt;code&gt;Results&lt;/code&gt; object since I&amp;rsquo;m going to be testing &lt;code&gt;Results.asObservable()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let messages$ = realm.objects(Message).asObservableChangeset().shareReplay(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m observing all &lt;code&gt;Message&lt;/code&gt; objects stored in my realm.&lt;/p&gt;

&lt;p&gt;Now comes the interesting part - first I&amp;rsquo;ll define when my expectation is fulfilled:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;messages$
  .scan(0, accumulator: {acc, _ in return acc+1})
  .filter { $0 == 3 }
  .map {_ in ()}
  .subscribeNext(expectation1.fulfill)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use &lt;code&gt;scan&lt;/code&gt; to count the emitted values from my observable, &lt;code&gt;filter&lt;/code&gt; helps me to pinpoint in which value I&amp;rsquo;m interested (the 3rd event), I map the value to &lt;code&gt;Void&lt;/code&gt; and subscribe to &lt;code&gt;expectation1.fulfill()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Long story short - when &lt;code&gt;messages$&lt;/code&gt; emits its 3rd event my expectation will fulfill. Neat!&lt;/p&gt;

&lt;p&gt;Since I&amp;rsquo;m not interested in just how many events are emitted but also which events were emitted, I need yet another subscription:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;messages$
  .map {results, changes in
    if let changes = changes {
      return &amp;quot;i:\(changes.inserted) d:\(changes.deleted) u:\(changes.updated)&amp;quot;
    } else {
      return &amp;quot;initial&amp;quot;
    }
  }
  .subscribe(observer)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it&amp;rsquo;s an update event I return a string with the collection indexes that were deleted or inserted, it looks like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i:[0] u:[] d:[1,2,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This logs all the information about the particular change-set that I&amp;rsquo;m interested in (and need to verify if the observable emitted the information I expected).&lt;/p&gt;

&lt;p&gt;If it&amp;rsquo;s the initial event for that collection I just return &amp;ldquo;initial&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;triggering-some-observable-values:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Triggering some Observable values&lt;/h2&gt;

&lt;p&gt;Now I can start the test scheduler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;scheduler.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, ultimately, perform some operations on my Realm to produce change notifications:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;delay(0.1) {
  try! realm.write {
    realm.add(Message(&amp;quot;first&amp;quot;))
  }
}
delay(0.2) {
  try! realm.write {
    realm.delete(realm.objects(Message).first!)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above adds a new object and after a bit of delay deletes it again. This should produce the 3 events I&amp;rsquo;m expecting: the initial data, the insert notification and the deletion notification.&lt;/p&gt;

&lt;h2 id=&#34;verifying-the-recorded-events-with-asserts:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Verifying the recorded events with asserts&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s time to (finally) add my asserts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;waitForExpectationsWithTimeout(0.5) {error in
    //do tests here
    
    XCTAssertTrue(error == nil)
    XCTAssertEqual(observer.events.count, 3)
    XCTAssertEqual(observer.events[0].value.element!, &amp;quot;initial&amp;quot;)
    XCTAssertEqual(observer.events[1].value.element!, &amp;quot;i:[0] d:[] u:[]&amp;quot;)
    XCTAssertEqual(observer.events[2].value.element!, &amp;quot;i:[] d:[0] u:[]&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the block I perform a number of asserts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;no error happened while fulfilling my expectations&lt;/li&gt;
&lt;li&gt;the test observer logged exactly 3 events&lt;/li&gt;
&lt;li&gt;the first emitted value is &amp;ldquo;initial&amp;rdquo;&lt;/li&gt;
&lt;li&gt;the second value is about inserting a value at index 0&lt;/li&gt;
&lt;li&gt;the third value is about deleting a value at index 0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s amazing how easy writing tests is even when testing two completely de-coupled libraries working together like RealmSwift and RxSwift. As you saw it&amp;rsquo;s a matter of 10-20 lines of code depending on your setup and I&amp;rsquo;m sure the code can be simplified even more.&lt;/p&gt;

&lt;p&gt;If you want to read through the complete test suite for RxRealm head to the GitHub repo test folder: &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxRealm/tree/master/Example/RxRealm_Tests&#34;&gt;RxRealm_Tests&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I hope this post has been useful! Do you know a better way to do any of this? Seen a bug? Ping me on Twitter at &lt;a href=&#34;https://twitter.com/icanzilb&#34;&gt;icanzilb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing your RxSwift code, part 1</title>
      <link>http://rx-marin.com/post/rxswift-rxtests-unit-tests/</link>
      <pubDate>Tue, 03 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxtests-unit-tests/</guid>
      <description>

&lt;p&gt;I sat down recently and learned the basics of writing unit tests for RxSwift. It was way easier than I expected and that&amp;rsquo;s why I&amp;rsquo;d like to show few of the tests I got to write.&lt;/p&gt;

&lt;p&gt;Before I start on the code itself I just want to mention how great contributing to open source is. If I didn&amp;rsquo;t jump in to helping around on the &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxSwift-Ext&#34;&gt;RxSwift-Ext&lt;/a&gt; project I&amp;rsquo;d probably haven&amp;rsquo;t looked into writing unit tests with RxSwift yet, but I did - and that&amp;rsquo;s great.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look at some of the unit tests I wrote&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;intro-to-rxtests:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Intro to RxTests&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;RxTests&lt;/strong&gt; is a separate library (available as well through CocoaPods), which you should import in your test target to be able to use some really handy classes to write your tests.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the Swift-Ext Podfile test target looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;target &#39;RxSwiftExtDemoTests&#39; do
	pod &#39;RxSwift+Ext&#39;
	pod &#39;RxSwift&#39;
	pod &#39;RxTests&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;RxTests&lt;/strong&gt; gives you few handy tools like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TestableObserver&amp;lt;ElementType&amp;gt;&lt;/code&gt; - an observer, which records all emitted events so you can inspect them and run your asserts on those events,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TestScheduler&lt;/code&gt; - a scheduler which let&amp;rsquo;s you control values and time, and let&amp;rsquo;s you create testable observers,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;== (lhs: Event&amp;lt;Element&amp;gt;, rhs: Event&amp;lt;Element&amp;gt;)&lt;/code&gt; adds &lt;code&gt;Equatable&lt;/code&gt; implementation to Rx events so you can easily check recorded events.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s have a look how to use those!&lt;/p&gt;

&lt;h2 id=&#34;simple-tests-for-an-rx-operator:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Simple tests for an rx operator&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part2/&#34;&gt;Custom convenience operators with RxSwift, Part 2&lt;/a&gt; I discussed creating the &lt;code&gt;unwrap()&lt;/code&gt; operator, which unwraps non-&lt;code&gt;nil&lt;/code&gt; values emitted by an observable.&lt;/p&gt;

&lt;p&gt;It took me a lot of time to make that operator work so when I saw folks contribute their operators to RxSwift-Ext I naturally also wanted to merge mine in.&lt;/p&gt;

&lt;p&gt;In order to do that though, I wanted to add unit tests first&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;drafting-a-unit-test-class:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Drafting a unit test class&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s how the setup of the unit tests file for &lt;code&gt;unwrap()&lt;/code&gt; looked like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import XCTest

import RxSwift
import RxSwift_Ext
import RxTests

class UnwrapTests: XCTestCase {
    private var observer: TestableObserver&amp;lt;Int&amp;gt;!
    let numbers: Array&amp;lt;Int?&amp;gt; = [1, nil, Int?(3), 4]
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class itself is a normal &lt;code&gt;XCTestCase&lt;/code&gt; test but it features a &lt;code&gt;TestableObserver&lt;/code&gt;. You have to specify what kind of values it will observe so that you can have compile time checks if your &lt;code&gt;Observable&lt;/code&gt; is emitting the data type you expect to have.&lt;/p&gt;

&lt;p&gt;For my tests I chose to test with an array of &lt;code&gt;Int?&lt;/code&gt; values since &lt;code&gt;unwrap()&lt;/code&gt; takes in a &lt;code&gt;Type?&lt;/code&gt; and returns &lt;code&gt;Type&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;numbers&lt;/code&gt; array is the sequence of values I&amp;rsquo;d use to feed into &lt;code&gt;unwrap()&lt;/code&gt; - it includes integers, a &lt;code&gt;nil&lt;/code&gt; value, and an Optional integer number.&lt;/p&gt;

&lt;h2 id=&#34;setup:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;setUp()&lt;/h2&gt;

&lt;p&gt;Next I needed to add a &lt;code&gt;setUp()&lt;/code&gt; method in the unit test class to prepare everything before the actual test methods run.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func setUp() {
    super.setUp()
        
    let scheduler = TestScheduler(initialClock: 0)
    observer = scheduler.createObserver(Int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;At this point I dug multiple times through the RxExample app included in the RxSwift repo in order to figure out how to use a test scheduler.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First of all my tests didn&amp;rsquo;t need to happen asynchronously so I didn&amp;rsquo;t have to use virtual time for my test scheduler. I set the initial clock at time &lt;code&gt;0&lt;/code&gt; and didn&amp;rsquo;t bother with time any further.&lt;/p&gt;

&lt;p&gt;After creating a test scheduler I created a test observer by calling &lt;code&gt;TestScheduler.createObserver(Type)&lt;/code&gt;. &lt;code&gt;Type&lt;/code&gt; is the type of values I expected the observer to capture from my &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point my code was ready to emit some values, I added:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;numbers.toObservable()
     .unwrap()
     .subscribe(observer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That code turned the initial array I had to an observable, fed it through &lt;code&gt;unwrap()&lt;/code&gt;, and finally sent it off to the test observer.&lt;/p&gt;

&lt;p&gt;The final line I added to &lt;code&gt;setUp()&lt;/code&gt; was:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;scheduler.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That would make the scheduler start running, have the observer consume all values from the sequence, and wrap-up.&lt;/p&gt;

&lt;h2 id=&#34;simple-checks-on-the-recorded-events:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Simple checks on the recorded events&lt;/h2&gt;

&lt;p&gt;I decided to start easy by checking if the list of recorded events matched some general expectations.&lt;/p&gt;

&lt;p&gt;First I wanted to check if &lt;code&gt;unwrap()&lt;/code&gt; filtered all &lt;code&gt;nil&lt;/code&gt; elements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testUnwrapFilterNil() {
    XCTAssertFalse(observer.events.contains {event in
        event.value == nil
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code just checks if none of the recorded events in &lt;code&gt;observer.events&lt;/code&gt; contains a &lt;code&gt;nil&lt;/code&gt; value. Done!&lt;/p&gt;

&lt;p&gt;Ok, what next? I wanted to see if the number of the output values is the one I expect: the number of the input values minus the amount of &lt;code&gt;nil&lt;/code&gt; values plus the &lt;code&gt;Complete&lt;/code&gt; event. I just added it to the same test method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;XCTAssertEqual(
    observer.events.count,
    numbers.count - 1/* the nr. of nil elements*/ + 1 /* complete event*/
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also done! Sweet.&lt;/p&gt;

&lt;h2 id=&#34;check-the-recorded-events:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Check the recorded events&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;TestObserver&lt;/code&gt; not only records the events that your &lt;code&gt;Observable&lt;/code&gt; emits but also the values they carried and the time marks they happened at.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s really easy to check if the events you expected were the ones recorded. Let&amp;rsquo;s have a look at what I did (again, how to do all of this I found in the RxSwift repo sources):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testUnwrapResultValues() {
    //test elements values and type
    let correctValues = [
        next(0, 1),
        next(0, 3),
        next(0, 4),
        completed(0)
    ]
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I defined an array of expected events - 3 &lt;code&gt;.Next&lt;/code&gt; events all happening at virtual time &lt;code&gt;0&lt;/code&gt; and  &lt;code&gt;.Completed&lt;/code&gt; event emitted when the input values are over.&lt;/p&gt;

&lt;p&gt;Now I just needed to compare the &lt;code&gt;correctValues&lt;/code&gt; array to the list of events &lt;code&gt;TestObserver&lt;/code&gt; has recorded:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;XCTAssertEqual(observer.events, correctValues)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s a wrap!&lt;/p&gt;

&lt;h2 id=&#34;conclusion:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It was easy and quite simple to write unit tests for &lt;code&gt;unwrap()&lt;/code&gt; because I could run all tests synchronously over the values of my input array. But &lt;code&gt;TestObserver&lt;/code&gt; and &lt;code&gt;TestScheduler&lt;/code&gt; allow for more complex unit tests as well. In part 2 I&amp;rsquo;ll look into writing simple asynchronous unit tests with RxSwift. Till then!&lt;/p&gt;

&lt;p&gt;If you want to have a look at the finished unit test class for &lt;code&gt;unwrap()&lt;/code&gt; you can find it here: &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxSwift-Ext/blob/master/Demo/RxSwiftExtDemoTests/UnwrapTests.swift#L9&#34;&gt;UnwrapTests.swift&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I hope this post has been useful! Do you know a better way to do any of this? Seen a bug? Ping me on Twitter at &lt;a href=&#34;https://twitter.com/icanzilb&#34;&gt;icanzilb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom convenience operators with RxSwift, Part 2</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part2/</link>
      <pubDate>Mon, 07 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part2/</guid>
      <description>

&lt;h2 id=&#34;intro:46ffa07f8102997fe7674832bad6bc33&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;I got some great feedback on last week&amp;rsquo;s post on convenience operators &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part1/&#34;&gt;part 1&lt;/a&gt; so I&amp;rsquo;m really excited to publish part 2, which I hope will be even more interesting for those of you who are looking into RxSwift.&lt;/p&gt;

&lt;p&gt;Without further ado let&amp;rsquo;s dive in code&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;a-better-negate-operator:46ffa07f8102997fe7674832bad6bc33&#34;&gt;A better negate() operator&lt;/h2&gt;

&lt;p&gt;First of all I have a better version of my &lt;code&gt;negate()&lt;/code&gt; operator from last week for you. What I wrote on my own was a pretty simple function that looked like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: BooleanType {
  public func negate() -&amp;gt; Observable&amp;lt;Bool&amp;gt; {
     return map {value in !value}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It doesn&amp;rsquo;t get simpler than that, right? You map a value in a single line of code and that&amp;rsquo;s it (careful, it&amp;rsquo;s a trick question).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tailec.com/&#34;&gt;@tailec&lt;/a&gt; grabbed me in Slack and showed me his version of the same operator, which definitely beats mine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: BooleanType {
    public func negate() -&amp;gt; Observable&amp;lt;Bool&amp;gt; {
        return map(!)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yup! Since &lt;code&gt;!&lt;/code&gt; is a function with a single parameter you can simply use in conjunction with &lt;code&gt;map&lt;/code&gt; as shown above. That code definitely looks better than mine and I&amp;rsquo;m gonna be using this version in my own projects too. Thanks &lt;a href=&#34;https://twitter.com/tailectailec&#34;&gt;Pawel&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Please guys, if you see something I&amp;rsquo;m posting here that can be improved get in touch, like Pawel did, and help get some awesome rx code out together!&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;filternegatives:46ffa07f8102997fe7674832bad6bc33&#34;&gt;filterNegatives()&lt;/h2&gt;

&lt;p&gt;I was looking over my current project&amp;rsquo;s code and trying to identify repeating patterns I can easily &lt;em&gt;outsource&lt;/em&gt; to a convenience operator.&lt;/p&gt;

&lt;p&gt;I noticed I have few &lt;code&gt;Bool&lt;/code&gt; observables that I am sometimes interested in only if they were emitting &lt;code&gt;true&lt;/code&gt; value. For example if we take the code from my &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/&#34;&gt;lap timer post&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let isRunning = [btnPlay.rx_tap.replaceWith(true), btnStop.rx_tap.replaceWith(false)]
  .toObservable()
  .merge()
  .startWith(false)
  .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which produces depending on taps on the play and stop buttons:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;true &amp;mdash; false &amp;mdash; true &amp;mdash; true &amp;ndash;&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How about observing only the taps on play? (Except just subscribing to the play button of course)&lt;/p&gt;

&lt;p&gt;Since what I wanted was to basically get rid of the all &lt;code&gt;false&lt;/code&gt; values I wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: BooleanType {
  public func filterNegatives() -&amp;gt; Observable&amp;lt;Bool&amp;gt; {
     return map {value in value.boolValue}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty easy piece of code, it does the work well and it&amp;rsquo;s clear to read. Great!&lt;/p&gt;

&lt;h2 id=&#34;replacenilwith:46ffa07f8102997fe7674832bad6bc33&#34;&gt;replaceNilWith(_)&lt;/h2&gt;

&lt;p&gt;This was an easy operator to implement. I had a couple of observables emitting optional values and I actually wanted to get a given &lt;em&gt;default&lt;/em&gt; value instead of &lt;code&gt;nil&lt;/code&gt;. I just had to map to a simple condition that checks for a &lt;code&gt;nil&lt;/code&gt; value like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable {
  func replaceNilWith(value: Element) -&amp;gt; Observable&amp;lt;Element&amp;gt; {
     return map {element in element == nil ? value : element}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the elements of the observable are still of type &lt;code&gt;Optional&amp;lt;Element&amp;gt;&lt;/code&gt; but you just never get a &lt;code&gt;nil&lt;/code&gt; value - you get your default value instead.&lt;/p&gt;

&lt;h2 id=&#34;filterout:46ffa07f8102997fe7674832bad6bc33&#34;&gt;filterOut(_)&lt;/h2&gt;

&lt;p&gt;While I was having a lot of momentum I decided to also write a filter that gets rid of specific values. Since the approach is exactly the same as before I&amp;rsquo;ll just add the code here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: Equatable {
    public func filterOut(targetValue: Element) -&amp;gt; Observable&amp;lt;Element&amp;gt; {
        return self.filter {value in targetValue != value}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting aspect about this piece of code is that to be able to identify the offending value in your sequence it needs to be &lt;code&gt;Equatable&lt;/code&gt; so you have to restrict the &lt;code&gt;filterOut&lt;/code&gt; operator to only observables that emit &lt;code&gt;Equatable&lt;/code&gt; elements.&lt;/p&gt;

&lt;p&gt;This of course is a walk in the park in Swift where you can just add &lt;code&gt;where Element: Equatable&lt;/code&gt; on your extension.&lt;/p&gt;

&lt;p&gt;The best thing about &lt;code&gt;filterOut(_)&lt;/code&gt; is that whenever I have an observable emitting optional values like for example &lt;code&gt;Observable&amp;lt;Bool?&amp;gt;&lt;/code&gt;, I can ensure no &lt;code&gt;nil&lt;/code&gt; values are emitted like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;optionalBoolSequence.filterOut(nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The observable elements are still of type &lt;code&gt;Optional&amp;lt;Bool&amp;gt;&lt;/code&gt; but now I am sure that the observable never emits a &lt;code&gt;nil&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;And leads me to &amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;unwrap:46ffa07f8102997fe7674832bad6bc33&#34;&gt;unwrap(_)&lt;/h2&gt;

&lt;p&gt;At that point I had two convenience operators to get rid of &lt;code&gt;nil&lt;/code&gt;s in my observables but the elements were still &lt;code&gt;Optional&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Well, I thought, it could not be so hard to actually unwrap the elements of an &lt;code&gt;Observable&lt;/code&gt; with all the Swift protocols black magic and such!&lt;/p&gt;

&lt;p&gt;Boy, was I &lt;strong&gt;totally&lt;/strong&gt; and &lt;strong&gt;completely&lt;/strong&gt; wrong&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/fry-wrong.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;My first realization was that &lt;code&gt;Optional&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; a protocol. Thus I couldn&amp;rsquo;t do any protocol black magic with it. Ugh!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; is actually an enum. Yes - this sounded pretty exciting when Swift 1.0 alpha was out, but honestly right now I&amp;rsquo;d expect that it was a protocol or something more flexible.&lt;/p&gt;

&lt;p&gt;Anywho, since &lt;code&gt;Optional&lt;/code&gt; isn&amp;rsquo;t a protocol I couldn&amp;rsquo;t create an extension on &lt;code&gt;Observable&lt;/code&gt; that matches optional elements. Gulp.&lt;/p&gt;

&lt;p&gt;I had a long long conversation with &lt;a href=&#34;https://twitter.com/mhollemans&#34;&gt;Matthijs&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/narrativium&#34;&gt;Ross O&amp;rsquo;Brien&lt;/a&gt; in Slack until in the end I could figure out the way&amp;hellip;&lt;/p&gt;

&lt;p&gt;First of all I had to define a protocol for optionals myself. My protocol had to define two methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;one that checks if the current value is &lt;code&gt;nil&lt;/code&gt; (guess what - simply comparing &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; didn&amp;rsquo;t really work, yay!)&lt;/li&gt;
&lt;li&gt;another that unwraps &lt;code&gt;self&lt;/code&gt; from &lt;code&gt;Optional&amp;lt;Type&amp;gt;&lt;/code&gt; to &lt;code&gt;Type&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The big question that I had to wrap my mind around was: What type is the unwrapped value? I didn&amp;rsquo;t know that in my protocol so I had to define a type that the concrete implementations would set.&lt;/p&gt;

&lt;p&gt;I ended up with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol Optionable
{
  typealias WrappedType
  func unwrap() -&amp;gt; WrappedType
  func isEmpty() -&amp;gt; Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool - I had a protocol which I could use to add a method to &lt;code&gt;Observable&lt;/code&gt; via an extension.&lt;/p&gt;

&lt;p&gt;But first I had to make the &lt;code&gt;Optional&lt;/code&gt; enum to conform to &lt;code&gt;Optionable&lt;/code&gt;. So &lt;code&gt;Optional&lt;/code&gt; exposes the type of the wrapped value via &lt;code&gt;Wrapped&lt;/code&gt; and that&amp;rsquo;s where the magic fusion between &lt;code&gt;Optional&lt;/code&gt; and my &lt;code&gt;Optionable&lt;/code&gt; protocol happened.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the declaration of &lt;code&gt;Optional&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum Optional&amp;lt;Wrapped&amp;gt; : _Reflectable, NilLiteralConvertible {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s how I wired &lt;code&gt;Optionable&lt;/code&gt; to to the type of any concrete optional value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Optional : Optionable
{
    typealias WrappedType = Wrapped
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha! &lt;em&gt;(Again Matthijs and Ross helped a lot along the way of untangling all of this. I must say that there is very little info online about protocol magic and associated types.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now I could also add the implementation of the two methods in the extension:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func unwrap() -&amp;gt; WrappedType {
    return self!
}

func isEmpty() -&amp;gt; Bool {
    return !(flatMap({_ in true})?.boolValue == true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You guessed it - coding &lt;code&gt;unwrap()&lt;/code&gt; was pretty straight forward, but &lt;code&gt;isEmpty()&lt;/code&gt; caused me serious headache.&lt;/p&gt;

&lt;p&gt;To my surprise (repeating myself here I know), &lt;code&gt;Optional&lt;/code&gt; doesn&amp;rsquo;t give you means to check whether it&amp;rsquo;s empty or not.&lt;/p&gt;

&lt;p&gt;At first I came with this na√Øve implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func isEmpty() -&amp;gt; Bool {
  switch self {
    case .None: return false
    case .Some(_): return true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, let me tell you: this doesn&amp;rsquo;t work. Although if you ask me it should. But it doesn&amp;rsquo;t - it never falls in the &lt;code&gt;case .None&lt;/code&gt; branch for some reason and is beyond me why.&lt;/p&gt;

&lt;p&gt;So I had to take the hard way, I looked again through everything I can find in an &lt;code&gt;Optional&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/optional-docs.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not much. Not much &amp;hellip;&lt;/p&gt;

&lt;p&gt;Wait! &lt;code&gt;flatMap&lt;/code&gt;? But of course! Here&amp;rsquo;s the (complete) docs on Optional&amp;rsquo;s flatMap:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Returns nil if self is nil, f(self!) otherwise.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I rewrote my &lt;code&gt;isEmpty()&lt;/code&gt; method to use &lt;code&gt;flatMap&lt;/code&gt; and I was off to the races:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func isEmpty() -&amp;gt; Bool {
    return !(flatMap({_ in true})?.boolValue == true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now (&lt;em&gt;finally&lt;/em&gt;) I could get to adding the extension to &lt;code&gt;Observable&lt;/code&gt;. Compared to all the rest I&amp;rsquo;ve been through this was &amp;hellip; let&amp;rsquo;s say &lt;em&gt;not so difficult&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element : Optionable {
  func unwrap() -&amp;gt; Observable&amp;lt;Element.WrappedType&amp;gt; {
    return self
      .filter {value in
        return !value.isEmpty()
      }
      .map {value -&amp;gt; Element.WrappedType in
        value.unwrap()
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notable mentions about that piece of code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;m matching the Observable type to &lt;code&gt;Optionable&lt;/code&gt;. &lt;code&gt;Optional&lt;/code&gt; implements &lt;code&gt;Optionable&lt;/code&gt; but if any other type does that &lt;code&gt;unwrap()&lt;/code&gt; will work for it too&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unwrap()&lt;/code&gt; takes in an &lt;code&gt;Element&lt;/code&gt; value and outputs &lt;code&gt;Element.WrappedType&lt;/code&gt;, so for &lt;code&gt;Int?&lt;/code&gt; outputs &lt;code&gt;Int&lt;/code&gt;, for &lt;code&gt;NSDate?&lt;/code&gt; outputs &lt;code&gt;NSDate&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;why not use &lt;code&gt;filterOut(nil)&lt;/code&gt; to get rid of the &lt;code&gt;nil&lt;/code&gt; values? &lt;code&gt;filterOut(_)&lt;/code&gt; works for &lt;code&gt;Equatable&lt;/code&gt; values and &lt;code&gt;Element.WrappedType&lt;/code&gt; might not be &lt;code&gt;Equatable&lt;/code&gt; in some cases&lt;/li&gt;
&lt;li&gt;I had to explicitly set the return type for my &lt;code&gt;map&lt;/code&gt; closure because Xcode thought things were getting a bit too abstract for it&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now let&amp;rsquo;s see the complete implementation (and if you can think of ways to simplify this please let me know, I still think there should be an easier way):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol Optionable
{
  typealias WrappedType
  func unwrap() -&amp;gt; WrappedType
  func isEmpty() -&amp;gt; Bool
}

extension Optional : Optionable
{
  typealias WrappedType = Wrapped
  func unwrap() -&amp;gt; WrappedType {
    return self!
  }
    
  func isEmpty() -&amp;gt; Bool {
    return !(flatMap({_ in true})?.boolValue == true)
  }
}

extension Observable where Element : Optionable {
  func unwrap() -&amp;gt; Observable&amp;lt;Element.WrappedType&amp;gt; {
    return self
      .filter {value in
        return !value.isEmpty()
      }
      .map {value -&amp;gt; Element.WrappedType in
        value.unwrap()
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well that was a fun day! To be fair I also learned quite a lot about protocols, associated types, etc.&lt;/p&gt;

&lt;p&gt;Later on I was talking to &lt;a href=&#34;https://twitter.com/fpillet&#34;&gt;@fpillet&lt;/a&gt; who shared this piece here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;someOptionalSequence
  .flatMap { $0 == nil ? Observable.empty() : Observable.just($0!) }`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s a one liner you can use directly on your Observable of &lt;code&gt;Optional&amp;lt;Element&amp;gt;&lt;/code&gt; type. It does pretty much the same as my &lt;code&gt;unwrap()&lt;/code&gt; operator but it&amp;rsquo;s way shorter because the &lt;code&gt;flatMap&lt;/code&gt; closure doesn&amp;rsquo;t need to specify its return type - it leaves it to Xcode to figure it out out of context.&lt;/p&gt;

&lt;p&gt;I still like my own operator though - I think it&amp;rsquo;s much more readable and it adds less stress to the compiler to write just:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;someOptionalSequence.unwrap()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/unwrap-doge.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:46ffa07f8102997fe7674832bad6bc33&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Creating your own convenience operators is awesome. The code is more readable, there is less opportunity to introduce bugs, and there&amp;rsquo;s nothing wrong with it.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m already planning the next post: creating your own Cocoa bindings. If you have done some cool custom bindings for UIKit classes, or any other interesting bindable properties let me know. Woot!&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom convenience operators with RxSwift, Part 1</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part1/</link>
      <pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part1/</guid>
      <description>

&lt;h2 id=&#34;intro:00ee3dba4704e83677ebf533fee4350e&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Just like when learning a new language you need to build up a dictionary to start understanding how the language works, you got to learn the Rx operators and everything will eventually click together.&lt;/p&gt;

&lt;p&gt;And then once you have a good common of a language it&amp;rsquo;s okay to start coming up with new words too to boost the expressiveness of your speech and for convenience.&lt;/p&gt;

&lt;p&gt;Same thing happened with me last week - for the first time I felt like I&amp;rsquo;m getting work done with RxSwift because I had good understanding how to use at least few operators. Naturally I wished to create my own custom convenience operators that would not do anything essentially new but will just help me express myself better and clearer.&lt;/p&gt;

&lt;h2 id=&#34;replacewith-value-replace-any-element-with-a-constant:00ee3dba4704e83677ebf533fee4350e&#34;&gt;replaceWith(value): Replace any element with a constant&lt;/h2&gt;

&lt;p&gt;When I just want to react to a certain group of events I replace the actual value emitted so that I can merge two or more Observables into one stream and observe that single stream.&lt;/p&gt;

&lt;p&gt;The following piece of code is from &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/&#34;&gt;last weeks&lt;/a&gt; post and observes the taps on the Start and Stop buttons of the laps timer app:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let isRunning = [btnPlay.rx_tap.map({_ in true}), btnStop.rx_tap.map({_ in false})]
	.toObservable()
    .merge()
    .startWith(false)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was looking at this chunk of code and thought that there should be a cleaner, more readable way to represent the mapping parts. What I do there for both observables is to ignore the actual value and replace it with a constant.&lt;/p&gt;

&lt;p&gt;So I dug through the RxSwift code and based on what I found there I put together this brilliant (hic) piece of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func replaceWith&amp;lt;R&amp;gt;(value: R) -&amp;gt; Observable&amp;lt;R&amp;gt; {
    return Observable.create { observer in
        let subscription = self.subscribe { e in
            switch e {
            case .Next(_):
                observer.on(.Next(value))
            case .Error(let error):
                observer.on(.Error(error))
            case .Completed:
                observer.on(.Completed)
            }
        }
        return subscription
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I create and return a new &lt;code&gt;Observable&lt;/code&gt; and pass through the &lt;code&gt;Error&lt;/code&gt; and &lt;code&gt;Completed&lt;/code&gt; events, but replace the value of the &lt;code&gt;Next&lt;/code&gt; event with the &lt;code&gt;value&lt;/code&gt; constant. Seems good?&lt;/p&gt;

&lt;p&gt;What looked like a magnificent piece of code turned out to be a bit of an overkill. I mean after all I just wanted to &amp;ldquo;map&amp;rdquo; any value of any type to a constant and when you say it that way the code almost writes itself! So in the end I rewrote the code like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension ObservableType {
    func replaceWith&amp;lt;R&amp;gt;(value: R) -&amp;gt; Observable&amp;lt;R&amp;gt; {
        return map { _ in value }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see I didn&amp;rsquo;t have to go crazy about the whole thing but just literally take the piece of code I wanted to re-use and abstract it in a method on the &lt;code&gt;ObservableType&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With this the same code block from the beginning of the post looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let isRunning = [btnPlay.rx_tap.replaceWith(true), btnStop.rx_tap.replaceWith(false)]
	.toObservable()
    .merge()
    .startWith(false)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! Having my own custom convenience operator made the code less prone to errors (no custom code in a closure to write) and more readable.&lt;/p&gt;

&lt;p&gt;At this point I started doubting myself a bit - this was too good to be true honestly. I thought I must be doing something wrong :)&lt;/p&gt;

&lt;p&gt;However it turned out many people have this exact custom operator in their code base, it apparently solves a common problem.&lt;/p&gt;

&lt;p&gt;Then I got a bit crazy and decided just for fun to explore how much further I can take this.&lt;/p&gt;

&lt;h2 id=&#34;replacewithdate-replace-with-timestamp-of-the-latest-value:00ee3dba4704e83677ebf533fee4350e&#34;&gt;replaceWithDate(): Replace with timestamp of the latest value&lt;/h2&gt;

&lt;p&gt;Since I was already warmed up by putting together &lt;code&gt;replaceWith&lt;/code&gt; I thought it&amp;rsquo;d be fun to have a convenience operator to give me the timestamp of the latest element from the observable sequence.&lt;/p&gt;

&lt;p&gt;In this concrete case the constant I&amp;rsquo;d replace the element with would just be the current date:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension ObservableType {
    func replaceWithDate&amp;lt;R&amp;gt;(value: R) -&amp;gt; Observable&amp;lt;NSDate&amp;gt; {
        return map { _ in NSDate() }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can bind the latest value from an Observable to a label, and show the timestamp of that value in another label like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let count = Observable&amp;lt;Int&amp;gt;
    .interval(3, scheduler: MainScheduler.instance)
    .shareReplay(1)

count.map {counter in &amp;quot;\(counter)&amp;quot;}
    .bindTo(label1.rx_text)
    .addDisposableTo(bag)

count.replaceWithDate()
    .map {$0.description}
    .bindTo(label2.rx_text)
    .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the result (wait few seconds to see the increments):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/latest-date.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;negate-negate-the-value-of-the-element:00ee3dba4704e83677ebf533fee4350e&#34;&gt;negate(): Negate the value of the element&lt;/h2&gt;

&lt;p&gt;Next I noticed that sometimes I need to bind an &lt;code&gt;Observable&lt;/code&gt; to &lt;code&gt;rx_enabled&lt;/code&gt; property of a button, and sometimes to &lt;code&gt;rx_hidden&lt;/code&gt;. While writing binding code I had to use numerous &lt;code&gt;map {value in !value}&lt;/code&gt;, which made my code less readable.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you check &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/&#34;&gt;last week&amp;rsquo;s post&lt;/a&gt; you will see that in my effort to increase readability I ended up having two observables: one called &lt;code&gt;isRunning&lt;/code&gt; and one &lt;code&gt;isntRunning&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After another read through some of RxSwift&amp;rsquo;s code I learned how to add an operator to an &lt;code&gt;Observable&lt;/code&gt; of a certain type. In my case I wanted to add the &lt;code&gt;negate()&lt;/code&gt; operator to just observables producing &lt;code&gt;Bool&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Observable&lt;/code&gt; exposes its elements&amp;rsquo; type as &lt;code&gt;Element&lt;/code&gt; and I could easily match this to the &lt;code&gt;BooleanType&lt;/code&gt; (Swift ftw!):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element: BooleanType {
    public func negate() -&amp;gt; Observable&amp;lt;Bool&amp;gt; {
        return map {value in !value}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sweet - thanks protocol extensions with associated types! Now I could easily write code like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;active.bindTo(btnStart.rx_enabled).addDisposableTo(bag)
active.negate().bindTo(btnStart.rx_hidden).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will both enable and show the button whenever &lt;code&gt;active&lt;/code&gt; emits a &lt;code&gt;true&lt;/code&gt; element. Pretty sleek eh?&lt;/p&gt;

&lt;p&gt;To wrap up today&amp;rsquo;s post here&amp;rsquo;s what I&amp;rsquo;ve also added to my project a bit later:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Observable where Element : SignedIntegerType {
    public func negate() -&amp;gt; Observable&amp;lt;E&amp;gt; {
        return map {value in -value}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;negate()&lt;/code&gt; worked also in other contexts. If you used it on &lt;code&gt;Observable&amp;lt;Bool&amp;gt;&lt;/code&gt; it would apply a logical &lt;code&gt;not&lt;/code&gt; to the value; if you used it on a &lt;code&gt;Observable&amp;lt;Int&amp;gt;&lt;/code&gt; it would produce the negative value of the element. Cool!&lt;/p&gt;

&lt;h2 id=&#34;conclusion:00ee3dba4704e83677ebf533fee4350e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Creating your own convenience operators is awesome. The code is more readable, there is less opportunity to introduce bugs, and there&amp;rsquo;s nothing wrong with it.&lt;/p&gt;

&lt;p&gt;In my next post I&amp;rsquo;ll look into few more operators I created along the way for myself. Do you want to share any of yours?&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on  Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Split laps timer with RxSwift and RxCocoa: Part 2</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-timer-app-useWithLatest-bindings/</guid>
      <description>&lt;p&gt;In my post from last week I worked on creating a split lapse timer app (&lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/&#34;&gt;last week&amp;rsquo;s post&lt;/a&gt;). But later on when I was playing with the application I noticed that I naturally would like to have means to start or stop the timer.&lt;/p&gt;

&lt;p&gt;Well this week I am implementing exactly this functionality.&lt;/p&gt;

&lt;p&gt;The first thing I thought about was how to implement state in my app because a timer clearly has two distinct states either running or not running. That got me thinking about combining signals, mapping, you know, all the good stuff.&lt;/p&gt;

&lt;p&gt;If you want to follow along you can download the starter project I prepared. It is in the shape where last weeks blog posts leaves off but I&amp;rsquo;ve added a couple of buttons in the user interface:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/latimer-new-ui.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Download the starter project to follow along here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer_starter.zip&#34;&gt;rx_laptimer_starter.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s put all those buttons to work!&lt;/p&gt;

&lt;p&gt;My very first idea was to try generating a sequence of values to describe the current state of the timer. The start button would produce &lt;code&gt;true&lt;/code&gt; values and the stop button will produce &lt;code&gt;false&lt;/code&gt; values. When merged I will get one sequence that emits every time the state changes:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;o---- (play tap) true--- (stop tap) false --- (play tap) true ---&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So at the top of &lt;code&gt;viewDidLoad()&lt;/code&gt; I created a new Observable like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isRunning = [btnPlay.rx_tap.map({_ in true}), btnStop.rx_tap.map({_ in false})]
    .toObservable()
    .merge()
    .startWith(false)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I mapped the taps on &lt;code&gt;btnPlay&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; and the taps on &lt;code&gt;btnStop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; and merged them together.&lt;/p&gt;

&lt;p&gt;The Observable starts with a &lt;code&gt;false&lt;/code&gt; value to give the user the opportunity to start the timer at their convenience.&lt;/p&gt;

&lt;p&gt;I printed the values the new observable emits and was quite happy with the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;isRunning.subscribeNext({state in
    print(state)
}).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code printed &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; in the console each time I pressed play or stop. Neato!&lt;/p&gt;

&lt;p&gt;Now it looked very easy to bind that Observable to the buttons&amp;rsquo; &lt;code&gt;rx_enabled&lt;/code&gt; property to actually make the UI reflect the timer state. I could as well hide the laps button when the timer isn&amp;rsquo;t running at all!&lt;/p&gt;

&lt;p&gt;And since some of the controls needed to be enabled when the timer is running and others when it isn&amp;rsquo;t - I made myself yet another observable and bound the controls like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isntRunning = isRunning.map({running in !running}).shareReplay(1)

isRunning.bindTo(btnStop.rx_enabled).addDisposableTo(bag)
isntRunning.bindTo(btnLap.rx_hidden).addDisposableTo(bag)
isntRunning.bindTo(btnPlay.rx_enabled).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The stop button is enabled while the timer is running. Play is enabled when the timer is paused.&lt;/p&gt;

&lt;p&gt;I really love this kind of code. No &lt;code&gt;if&lt;/code&gt;s no &lt;code&gt;switch&lt;/code&gt;es; once you get the code running it&amp;rsquo;s very difficult to mess up and there&amp;rsquo;s simply no space for introducing bugs. Everything is air-tight.&lt;/p&gt;

&lt;p&gt;The app started with the laps button hidden and only the play button enabled like so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-play.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Further you could click play just once because it instantly became disabled. How cool :]&lt;/p&gt;

&lt;p&gt;Now my problem was that even though the UI already reflected the different states of the timer - well &amp;hellip; the timer didn&amp;rsquo;t care at all about any of that :]&lt;/p&gt;

&lt;p&gt;I looked into the &lt;code&gt;RxSwift&lt;/code&gt; implementation of a timer but didn&amp;rsquo;t find a way how to pause it (I guess that it couldn&amp;rsquo;t implement state, who knows &amp;hellip;). That&amp;rsquo;s why I thought I&amp;rsquo;d move away from directly binding the timer to the UI and implement my own counter.&lt;/p&gt;

&lt;p&gt;At the time my timer looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, I thought, I just need to somehow combine &lt;code&gt;isRunning&lt;/code&gt; and &lt;code&gt;timer&lt;/code&gt; and filter the observable output when &lt;code&gt;isRunning&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So I did the following: I appended to the existing &lt;code&gt;timer&lt;/code&gt; an operator to combine it with the latest value from &lt;code&gt;isRunning&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.withLatestFrom(isRunning, resultSelector: {_, running in running})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You see that I just ignored the value emitted by &lt;code&gt;timer&lt;/code&gt; since I never use it for anything and return from &lt;code&gt;withLatestFrom&lt;/code&gt; the unchanged &lt;code&gt;running&lt;/code&gt; input parameter:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(Int, Boolean) -&amp;gt; withLatestFrom -&amp;gt; Boolean&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Next I could simply use &lt;code&gt;filter&lt;/code&gt; to stop the observable from emitting when the timer is not running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.filter({running in running})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And last but not least I had to attach a counter, but that was already something I knew how to do with &lt;code&gt;scan&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.scan(0, accumulator: {(acc, _) in
    return acc+1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What &lt;code&gt;scan&lt;/code&gt; does above is to count how many times the timer fired while &lt;code&gt;isRunning&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; (which is exactly what I wanted).&lt;/p&gt;

&lt;p&gt;Finally I had to set the initial value to show in the UI and to share the result between all observers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; .startWith(0)
 .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete code of the enhanced timer observable looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)
    .withLatestFrom(isRunning, resultSelector: {_, running in running})
    .filter({running in running})
    .scan(0, accumulator: {(acc, _) in
        return acc+1
    })
    .startWith(0)
    .shareReplayLatestWhileConnected()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s a wrap :] Now my timer app had a stateful UI and split lap all implemented without a single &lt;code&gt;if&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-2-final.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can get the completed project from here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer_finished.zip&#34;&gt;rx_laptimer_finished.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on  Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Split laps timer with RxSwift and RxCocoa</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/</link>
      <pubDate>Tue, 16 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/</guid>
      <description>

&lt;p&gt;I was browsing through &lt;a href=&#34;http://rxmarbles.com/&#34;&gt;RxMarbles&lt;/a&gt; and was totally baffled by the &lt;code&gt;sample&lt;/code&gt; function. The marble diagram looks pretty random at first sight:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/marbles-sample.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At first I thought - &amp;ldquo;Hey, that second sequence is getting totally ignored!&amp;rdquo;. But after I read the description I figured it out:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The first sequence&amp;rsquo;s elements is &lt;strong&gt;what&lt;/strong&gt; &lt;code&gt;sample&lt;/code&gt; emits, while the second sequence&amp;rsquo;s elements determine &lt;strong&gt;when&lt;/strong&gt; &lt;code&gt;sample&lt;/code&gt; emits. So in a way yes - the actual values A, B, C, D do get totally ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When it was clear to me what &lt;code&gt;sample&lt;/code&gt; does I started wondering if this function has any practical application :]&lt;/p&gt;

&lt;p&gt;This brought me to creating a split lap timer app to test what &lt;code&gt;sample&lt;/code&gt; can do for me. In the finished project I have a timer emitting time values (aka the first sequence) and I want to grab (or sample) the values whenever the user taps a button (aka the second sequence).&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the marble diagram looks like for the app setup:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/sample-dia.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this is how the app looks like when finished:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-finished.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s build that app :]&lt;/p&gt;

&lt;p&gt;Here are the specs I wanted for my split lap timer app:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;start the timer at launch&lt;/li&gt;
&lt;li&gt;show the running time in format MM:SS.MS&lt;/li&gt;
&lt;li&gt;when the user taps &amp;ldquo;Split Lap&amp;rdquo; add a split time&lt;/li&gt;
&lt;li&gt;show a table of the split times&lt;/li&gt;
&lt;li&gt;show a table head with the total of laps&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-start-a-timer:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;1 Start a timer&lt;/h3&gt;

&lt;p&gt;Like in my &lt;a href=&#34;http://rx-marin.com/post/rxswift-timer-sequence-manual-dispose-bag/&#34;&gt;previous post&lt;/a&gt; about manually disposing bag&amp;rsquo;s contents I added a timer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var timer: Observable&amp;lt;NSInteger&amp;gt;!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in &lt;code&gt;viewDidLoad&lt;/code&gt; let it run every &lt;code&gt;1/10&lt;/code&gt; of a second (I chose to show only 1 digit for milliseconds so no need to fire more often):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//create the timer
timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.1, scheduler: MainScheduler.instance)

timer.subscribeNext({ msecs -&amp;gt; Void in
  print(&amp;quot;\(msecs)00ms&amp;quot;)
}).addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This got the timer running and filling up the console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;000ms
100ms
200ms
300ms
400ms
500ms
600ms
700ms
800ms
900ms
1000ms
1100ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool - that was easy (well, I already knew how to do that part, lol)&lt;/p&gt;

&lt;h3 id=&#34;2-show-the-current-elapsed-time:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;2 Show the current elapsed time&lt;/h3&gt;

&lt;p&gt;This was also a part I already knew how to do. First I put together a little function to take the elapsed time and return a nicely formatted string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func stringFromTimeInterval(ms: NSInteger) -&amp;gt; String {
  return String(format: &amp;quot;%0.2d:%0.2d.%0.1d&amp;quot;,
    arguments: [(ms / 600) % 600, (ms % 600 ) / 10, ms % 10])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then back in &lt;code&gt;viewDidLoad&lt;/code&gt; I used it to bind the timer to a label I added via Interface Builder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//wire the chrono
timer.map(stringFromTimeInterval)
  .bindTo(lblChrono.rx_text)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really love how the code flows and tells the story of what should happen:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;timer -&amp;gt; 1,2,3 -&amp;gt; stringFromTimeInterval -&amp;gt; &amp;quot;string&amp;quot;, &amp;quot;string&amp;quot; -&amp;gt; lblChrono&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Functional code is awesome because I get 2 huge wins for free: I can easily reuse &lt;code&gt;stringFromTimeInterval&lt;/code&gt; and I can write very simple tests for it.&lt;/p&gt;

&lt;p&gt;At this point the timer label already displayed the elapsed time:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-label.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-grab-the-split-time-when-the-user-taps-the-split-lap-button:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;3 Grab the split time when the user taps the &amp;ldquo;Split Lap&amp;rdquo; button&lt;/h3&gt;

&lt;p&gt;Ok here I was supposed to have my ultimate win by using &lt;code&gt;sample&lt;/code&gt;. The first few tries didn&amp;rsquo;t get me far until I realized that the &lt;code&gt;rx_tap&lt;/code&gt; property on &lt;code&gt;UIButton&lt;/code&gt; is also an &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Duh, everything is an &lt;code&gt;Observable&lt;/code&gt; :]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then it was just a matter of calling &lt;code&gt;sample&lt;/code&gt; on my timer and providing as a control sequence the &lt;code&gt;rx_tap&lt;/code&gt; property of the button like so: &lt;code&gt;timer.sample(btnLap.rx_tap)&lt;/code&gt; Whaaaat?&lt;/p&gt;

&lt;p&gt;Now each time I tapped the button &lt;code&gt;sample&lt;/code&gt; emitted the latest value produced by &lt;code&gt;timer&lt;/code&gt;. And since I wasn&amp;rsquo;t interested in the number but in the formatted string I again mapped the result with &lt;code&gt;stringFromTimeInterval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And since I needed to build a list of those split times I used &lt;code&gt;scan&lt;/code&gt;. Actually at first I came around &lt;code&gt;reduce&lt;/code&gt; because I was thinking of accumulating values in a list, but then realized I needed to produce a sequence that emits the list for each new value&amp;hellip; hence I kind of knew I got to use &lt;code&gt;scan&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let lapsSequence = timer.sample(btnLap.rx_tap)
    .map(stringFromTimeInterval)
    .scan([String](), accumulator: {lapTimes, newTime in
        return lapTimes + [newTime]
    })
    .shareReplay(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So - each time &lt;code&gt;sample&lt;/code&gt; emits a new lap time &lt;code&gt;scan&lt;/code&gt; emits an array of all the split times so far.&lt;/p&gt;

&lt;p&gt;Not sure how to explain &lt;code&gt;scan&lt;/code&gt; more simply but I&amp;rsquo;ll try: In RxSwift any time you&amp;rsquo;re thinking of using &lt;code&gt;reduce&lt;/code&gt; chances are you need &lt;code&gt;scan&lt;/code&gt; instead :]&lt;/p&gt;

&lt;h3 id=&#34;4-show-a-table-of-the-split-times-so-far:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;4 Show a table of the split times so far&lt;/h3&gt;

&lt;p&gt;Ok so I got &lt;code&gt;lapsSequence&lt;/code&gt; emit an array of split times. From there (after consulting RxExample) was a walk in the park to wire up the table view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//show laps in table
lapsSequence.bindTo(tableView.rx_itemsWithCellIdentifier(&amp;quot;Cell&amp;quot;, cellType: UITableViewCell.self)) { (row, element, cell) in
    cell.textLabel!.text = &amp;quot;\(row+1)) \(element)&amp;quot;
}
.addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And my app was already working!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-table.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Each time I tap the &amp;ldquo;Split Lap&amp;rdquo; button I get a new split time added in the table view. Sweet!&lt;/p&gt;

&lt;h3 id=&#34;5-show-a-table-header-with-the-number-of-laps:1db2c1bfd63c48e8c3c8b2b212141dce&#34;&gt;5 Show a table header with the number of laps&lt;/h3&gt;

&lt;p&gt;This part was the one that tripped me the most. There wasn&amp;rsquo;t a binding I could use for the table header and I didn&amp;rsquo;t want to complicate the code unneccessarily by adding a section table data source.&lt;/p&gt;

&lt;p&gt;What came to mind was to add a &lt;code&gt;UILabel&lt;/code&gt; property to my view controller and use it as the table header view. Then bind the count of split times to the &lt;code&gt;rx_text&lt;/code&gt; of that label.&lt;/p&gt;

&lt;p&gt;So I added to the view controller class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let tableHeaderView = UILabel()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then an extension to set this label as my table view header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension ViewController: UITableViewDelegate {
  func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -&amp;gt; UIView? {
    return tableHeaderView
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I knew how to set my class as the proxy delegate to the table view (back in &lt;code&gt;viewDidLoad&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//set table delegate
tableView
  .rx_setDelegate(self)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now came the coup d&amp;rsquo;etat - I had to map &lt;code&gt;lapsSequence&lt;/code&gt; from an array to a single string (e.g. &amp;ldquo;5 laps&amp;rdquo;) and bind that string to the table header.&lt;/p&gt;

&lt;p&gt;I got overexcited about using &lt;code&gt;scan&lt;/code&gt; but the code did feel itchy so after asking around on the RxSwift slack &lt;a href=&#34;https://twitter.com/KrunoslavZaher&#34;&gt;KrunoslavZaher&lt;/a&gt; enlightened me that since I have one array I can turn it into one string by simply using &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the final code addition to &lt;code&gt;viewDidLoad&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//update the table header
lapsSequence.map({ laps -&amp;gt; String in
    return &amp;quot;\t\(laps.count) laps&amp;quot;
})
.startWith(&amp;quot;\tno laps&amp;quot;)
.bindTo(tableHeaderView.rx_text)
.addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;lapsSequence&lt;/code&gt; emits an array of &lt;em&gt;all&lt;/em&gt; split times each time a new split time is emitted I just take that array and return a string with the number of elements.&lt;/p&gt;

&lt;p&gt;Additionally I set the initial value to &amp;ldquo;no laps&amp;rdquo; and that&amp;rsquo;s pretty much it - I bind everything directly to &lt;code&gt;tableHeaderView.rx_text&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s the complete working app!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/laptimer-finished.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can download the completed project and give it a try here: &lt;a href=&#34;http://rx-marin.com/zip/rx_laptimer.zip&#34;&gt;rx_laptimer.zip&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Manually disposing a bag and creating a timer</title>
      <link>http://rx-marin.com/post/rxswift-timer-sequence-manual-dispose-bag/</link>
      <pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-timer-sequence-manual-dispose-bag/</guid>
      <description>&lt;p&gt;I was reading through the &lt;a href=&#34;https://github.com/ReactiveX/RxSwift/tree/master/Documentation&#34;&gt;RxSwift docs&lt;/a&gt; and did a little test to see if I understood manual disposing. As the example made a lot of sense I thought it&amp;rsquo;s not a bad idea to share it online.&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;DisposeBag&lt;/code&gt; kind of &lt;code&gt;retains&lt;/code&gt; all your observables that&amp;rsquo;s why you add them to a bag all the time when you create them. You probably never get to dispose them manually since the moment the bag gets disposed it also disposes all your observables (magic!).&lt;/p&gt;

&lt;p&gt;To test disposing I wrote this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

import RxSwift
import RxCocoa


class ViewController: UIViewController {

    var bag: DisposeBag! = DisposeBag()
    var sig: Observable&amp;lt;Int&amp;gt;!
    
    override func viewDidLoad() {
        super.viewDidLoad()

        sig = Observable&amp;lt;Int&amp;gt;.interval(1.0, scheduler: MainScheduler.instance)
        
        sig.map({num in
            num * 10
        }).subscribeNext({num in
            print(num)
        }).addDisposableTo(bag)
        
        
        let tap = UITapGestureRecognizer(target: self, action: &amp;quot;didTap&amp;quot;)
        view.addGestureRecognizer(tap)
    }

    func didTap() {
        bag = nil
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Observable&amp;lt;Int&amp;gt;.interval(:scheduler:)&lt;/code&gt; creates a sequence that emits each time the timer fires - in the case of the example above each second the observable emits the next integer number.&lt;/p&gt;

&lt;p&gt;I map the value and finally in &lt;code&gt;subscribeNext()&lt;/code&gt; I print to the console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0
10
20
30
40
etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I attached a gesture recognizer to the view controller&amp;rsquo;s view and when the user taps on the view I destroy the bag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;bag = nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you give the code a try you will see that when you tap the view the observable stops emitting because the original bag get destroyed and it automatically disposes of all observables added to it.&lt;/p&gt;

&lt;p&gt;Very nice and handy when you need to be sure when a resource is deallocated. Further - how cool is that you can create a timer by simply doing &lt;code&gt;Observable&amp;lt;Int&amp;gt;.interval(:scheduler:)&lt;/code&gt;?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>