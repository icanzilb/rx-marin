<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rx_marin&lt;blog&gt;</title>
    <link>http://rx-marin.com/</link>
    <description>Recent content on rx_marin&lt;blog&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Sep 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://rx-marin.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Custom property bindings with RxSwift</title>
      <link>http://rx-marin.com/post/rxswift-custom-bindings/</link>
      <pubDate>Tue, 19 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-custom-bindings/</guid>
      <description>

&lt;p&gt;Recently, in one of the few meetups I&amp;rsquo;ve been in person to, someone told me the didn&amp;rsquo;t try RxSwift because somebody told them that RxSwift doesn&amp;rsquo;t support custom views.&lt;/p&gt;

&lt;p&gt;While I&amp;rsquo;m still baffled what that original person meant, I thought the best way to disagree is to write a short tutorial to prove them wrong.&lt;/p&gt;

&lt;h2 id=&#34;what-are-custom-property-sinks:614ccbc09013a93ad6e5b11beb304f3a&#34;&gt;What are custom property sinks?&lt;/h2&gt;

&lt;p&gt;When you use RxCocoa bindings you can easily bind the values an observable emits to some view on screen like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myObservable
  .map { &amp;quot;new value is \($0)&amp;quot; }
  .bind(to: myLabel.rx.text )
  .disposed(by: bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But have you ever wondered what &lt;code&gt;rx.text&lt;/code&gt; is and what so magical is there about it? Nothing. There&amp;rsquo;s nothing magical - just Cmd click on it and you will see the source code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Reactive where Base: UILabel {
    /// Bindable sink for `text` property.
    public var text: UIBindingObserver&amp;lt;Base, String?&amp;gt; {
        return UIBindingObserver(UIElement: self.base) { label, text in
            label.text = text
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The extension adds the property &lt;code&gt;text&lt;/code&gt; to the &lt;code&gt;Reactive&lt;/code&gt; struct (this is effectively the &lt;code&gt;rx&lt;/code&gt; property on classes with reactive extensions) but only to the class &lt;code&gt;UILabel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;text&lt;/code&gt; itself is of type &lt;code&gt;UIBindingObserver&lt;/code&gt; - it&amp;rsquo;s simply an observer similar to any other, that receives values and decides how to process them.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: In RxSwift 4 &lt;code&gt;UIBindingObserver&lt;/code&gt; has been changed to &lt;code&gt;Binder&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When you bind an observable subscription to the &lt;code&gt;text&lt;/code&gt; property, the property returns a new observer which executes its block parameter when each value is emitted. E.g. any time it receives a new value it runs the code &lt;code&gt;label.text = text&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s &lt;strong&gt;literally&lt;/strong&gt; all there is to adding a bindable sink property to a class - in your code you might be binding a &lt;code&gt;UIColor&lt;/code&gt; value instead of &lt;code&gt;String&lt;/code&gt;, or adding a reactive extension to &lt;code&gt;UIApplication&lt;/code&gt; instead of &lt;code&gt;UILabel&lt;/code&gt; like in the example above, but the very simple demonstrated technique stays the same.&lt;/p&gt;

&lt;h2 id=&#34;adding-a-reactive-extension-to-swiftspinner:614ccbc09013a93ad6e5b11beb304f3a&#34;&gt;Adding a reactive extension to SwiftSpinner&lt;/h2&gt;

&lt;p&gt;To show the code in action let&amp;rsquo;s add a quick reactive extension to the &lt;a href=&#34;https://github.com/icanzilb/SwiftSpinner&#34;&gt;SwiftSpinner&lt;/a&gt; library.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m creating a new Xcode project and importing all the pods I need for the demo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftSpinner
import RxSwift
import RxCocoa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I&amp;rsquo;m adding a reactive extension on the &lt;code&gt;SwiftSpinner&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Reactive where Base: SwiftSpinner {
  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will add an &lt;code&gt;rx&lt;/code&gt; property to SwiftSpinner instances. Further I&amp;rsquo;ll add the property &lt;code&gt;progress&lt;/code&gt; so I can bind observables emitting &lt;code&gt;Int&lt;/code&gt; values to it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public var progress: UIBindingObserver&amp;lt;Base, Int&amp;gt; {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally I&amp;rsquo;m converting values between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;100&lt;/code&gt; and call &lt;code&gt;SwiftSpinner.show(progress:title:)&lt;/code&gt; to display the current progress on screen and the complete code is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Reactive where Base: SwiftSpinner {
    public var progress: UIBindingObserver&amp;lt;Base, Int&amp;gt; {
        return UIBindingObserver(UIElement: self.base) { spinner, progress in
            let progress = max(0, min(progress, 100))
            SwiftSpinner.show(progress: Double(progress)/100.0, title: &amp;quot;\(progress)% completed&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it. Let&amp;rsquo;s test the new reactive extension:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    Observable&amp;lt;Int&amp;gt;.timer(0.0, period: 0.15, scheduler: MainScheduler.instance)
        .bind(to: SwiftSpinner.sharedInstance.rx.progress )
        .disposed(by: bag)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see that timer drive the progress bar like a mad man:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/swiftspinner.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s a wrap! If anyone is misinformed about how easy it is to create reactive extensions with RxSwift send them read this post!&lt;/p&gt;

&lt;h2 id=&#34;where-to-go-from-here:614ccbc09013a93ad6e5b11beb304f3a&#34;&gt;Where to go from here?&lt;/h2&gt;

&lt;p&gt;Dig into the source code of RxCocoa - there&amp;rsquo;s no better way to learn about creating bindable sinks. Or even better - get our book about RxSwift :)&lt;/p&gt;

&lt;p&gt;The book is available at &lt;a href=&#34;https://store.raywenderlich.com/products/rxswift?source=underplot&#34;&gt;http://raywenderlich.com/store&lt;/a&gt; - this is where you can see any updates, discuss in the website forums, etc.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raffling my ticket to NSSpain 2017</title>
      <link>http://rx-marin.com/post/nsspain-ticket/</link>
      <pubDate>Tue, 15 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/nsspain-ticket/</guid>
      <description>&lt;p&gt;This year is the 5th edition of &lt;a href=&#34;https://2017.nsspain.com&#34;&gt;NSSpain&lt;/a&gt; - the only international iOS/macOS conference in Spain and one of the best in the world I&amp;rsquo;ve been to. There are many reasons why I think NSSpain is the right way to do a conference, including but not limited to - single track, remote location, and best-in-business speakers&amp;hellip; &lt;em&gt;(And that&amp;rsquo;s why last year I sponsored a student-ticket to NSSpain.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Speakers receive not only free entry to the full conference and free accomodation, but also tons of love from the organizers. (You will probably be surprised but not all iOS confs provide free entry/accomodation/travel to speakers even if speakers do speak for free.)&lt;/p&gt;

&lt;p&gt;I will lead an RxSwift workshop and give a talk at NSSpain 2017, and therefore I will receive a refund for the ticket I already bought. &lt;strong&gt;HOWEVER&lt;/strong&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip; a bro in IT, a bro-ogler, decided to attack a huge group of our colleagues last week based on their gender and for literally everyone in the industry this ought to be unacceptable.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to &lt;em&gt;manifest&lt;/em&gt; (lol) that not all men in tech are like him, so I will raffle my NSSpain ticket instead of getting my money back.&lt;/p&gt;

&lt;p&gt;In order to participate in the raffle you must be (aka the rules):&lt;/p&gt;

&lt;p&gt;1) a woman in tech (no bros sorry - my ticket, my rules)&lt;/p&gt;

&lt;p&gt;&lt;del&gt;2) maintain a repo or have successfully done a meaningful PR to a Swift/ObjC library (no typo fixes, etc.)&lt;/del&gt; rule number two is removed by popular request&lt;/p&gt;

&lt;p&gt;3) ping me on twitter &lt;a href=&#34;https://twitter.com/icanzilb&#34;&gt;@icanzilb&lt;/a&gt; or chose your preferred way to contact me from &lt;a href=&#34;http://www.underplot.com&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I will raffle the names and ping the one of you who gets the ticket on Aug 21st so you can arrange your travel.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;Additionally I will retweet all qualifying entries to give you more visibility and ask ppl I know to retweet as well. If you tag your submission with &lt;code&gt;#WITBragDay&lt;/code&gt; probably even more people will pick it up and retweet.&lt;/del&gt; Since I got so much backlash about trying to promote OSS via this raffle, the re-tweeting part also is discontinued.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s the plan! :) Let&amp;rsquo;s do it!&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll see you all at NSSpain.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First update to the RxSwift book with version 1.1</title>
      <link>http://rx-marin.com/post/rxswift-rxswift-book-update-1.1/</link>
      <pubDate>Thu, 01 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxswift-book-update-1.1/</guid>
      <description>

&lt;p&gt;This is a short update about the first update to our RxSwift book.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First of all&lt;/strong&gt;, we&amp;rsquo;d like to thank all of you who posted to our book errata forum!  (and if you haven&amp;rsquo;t hit the forums yet, check &amp;lsquo;em out - it&amp;rsquo;s the best place to report typos, bugs, and more: &lt;a href=&#34;https://forums.raywenderlich.com/c/books/rxswift&#34;&gt;https://forums.raywenderlich.com/c/books/rxswift&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve worked with the raywenderlich.com team on a number of books and I must say the RxSwift book has had, so far, the most enthusiastic feedback - we&amp;rsquo;ve been drowned in questions, thank you messages, and typo/bugs reports. Again - &lt;strong&gt;thank you&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve addressed the most part of the feedback, and are looking for more - so if you see something that doesn&amp;rsquo;t feel or spell right, let us know.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Further&lt;/strong&gt; we&amp;rsquo;ve updated and tested the book projects on &lt;strong&gt;Xcode 8.3.2&lt;/strong&gt; and with &lt;strong&gt;RxSwift 3.4&lt;/strong&gt; - few APIs became deprecated since we published the book so to provide best experience for the readers we&amp;rsquo;ve updated the code to the latest syntax. There were few changes touching almost all code in the book like changing &lt;code&gt;addDisposeableTo(_)&lt;/code&gt; to &lt;code&gt;disposed(by:)&lt;/code&gt;, and &lt;code&gt;bindTo(_)&lt;/code&gt; to &lt;code&gt;bind(to:)&lt;/code&gt;. If you use the code from the initial book version that&amp;rsquo;ll still work fine but it will generate warnings asking you to change to the latest syntax.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Last, but not least&lt;/strong&gt;, we&amp;rsquo;ve updated the text in few places - we&amp;rsquo;ve noticed some repeating questions and figured that few spots needed more clarifications. So please keep asking us - it helps a lot!&lt;/p&gt;

&lt;h2 id=&#34;how-to-update:f6c2e1bea7467fd778e61928bf8f2f2b&#34;&gt;How to update?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1) Head to your profile page on raywenderlich.com&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/update-profile.png&#34; alt=&#34;profile page&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) Click on &amp;ldquo;My Products&amp;rdquo; tab&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/update-products.png&#34; alt=&#34;my products&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3) You will see all your purchases; click on the RxSwift book&lt;/strong&gt; (it has a &amp;ldquo;new&amp;rdquo; icon on top of it)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/update-book.png&#34; alt=&#34;updated book cover&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4) Scroll down the book page and download the latest version&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/update-download.png&#34; alt=&#34;update download&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it - &lt;strong&gt;enjoy&lt;/strong&gt;!&lt;/p&gt;

&lt;h2 id=&#34;where-to-go-from-here:f6c2e1bea7467fd778e61928bf8f2f2b&#34;&gt;Where to go from here?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;if you&amp;rsquo;ve found a typo, something is not clear, or you found a bug: head to the book forums &lt;a href=&#34;https://forums.raywenderlich.com/c/books/rxswift&#34;&gt;https://forums.raywenderlich.com/c/books/rxswift&lt;/a&gt; and let us know!&lt;/li&gt;
&lt;li&gt;if you&amp;rsquo;d like to chat about RxSwift in general: join over 3,000+ RxSwift developers in the RxSwift slack &lt;a href=&#34;http://rxswift-slack.herokuapp.com/&#34;&gt;http://rxswift-slack.herokuapp.com/&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See you next time!&lt;/p&gt;

&lt;p&gt;The book is available &lt;strong&gt;ONLY&lt;/strong&gt; at &lt;a href=&#34;https://store.raywenderlich.com/products/rxswift?source=underplot&#34;&gt;http://raywenderlich.com/store&lt;/a&gt; - this is where you get free updates, discuss in the website forums, etc.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>combineLatest beyond the basics</title>
      <link>http://rx-marin.com/post/rxswift-advanced-combine-latest/</link>
      <pubDate>Fri, 19 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-advanced-combine-latest/</guid>
      <description>

&lt;p&gt;In the last couple of weeks I got to talk to few people who were either still struggling to understand what exactly does &lt;code&gt;combineLatest&lt;/code&gt; do or didn&amp;rsquo;t know about a more recent power feature.&lt;/p&gt;

&lt;p&gt;So here it is &amp;hellip; a post about &lt;code&gt;combineLatest&lt;/code&gt;!&lt;/p&gt;

&lt;h2 id=&#34;what-does-the-combinelatest-operator-do:5c9f9259b42e6e7edba2de9c8047659b&#34;&gt;What does the combineLatest operator do?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;combineLatest&lt;/code&gt; is super useful and it was the first thing in RxSwift that really made see how powerful Rx is and showed me what kind of problems can be easily solved with RxSwift.&lt;/p&gt;

&lt;p&gt;So what does it do? Any time any of the source sequences emits an element, also &lt;code&gt;combineLatest&lt;/code&gt;&amp;rsquo;s result seqiemce emits an element, which contains all the latest values of each of the source sequences.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at a marble diagram (source: &lt;a href=&#34;http://rxmarbles.com/#combineLatest&#34;&gt;http://rxmarbles.com/#combineLatest&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/combineLatest.png&#34; alt=&#34;combineLatest schema&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We have two sequences S1 and S2, which emit values - the former emits numbers and the latter - letters.&lt;/p&gt;

&lt;p&gt;After all source sequences emit for the first time (e.g. they do have a &lt;em&gt;latest&lt;/em&gt; value), when any of the sources emits an element &lt;code&gt;combineLatest&lt;/code&gt; grabs the latest values of all sources and emits the combined result.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look what happens on the diagam above:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;first, S1 emits &lt;code&gt;1&lt;/code&gt; - since not all sources have emitted at that time, the result does not emit&lt;/li&gt;
&lt;li&gt;then, S1 emits &lt;code&gt;2&lt;/code&gt; - same thing happens since S2 still hasn&amp;rsquo;t emitted anything (e.g. has no latest value)&lt;/li&gt;
&lt;li&gt;then S2 emits &lt;code&gt;A&lt;/code&gt; - at that point all sources have a &lt;em&gt;latest&lt;/em&gt; element so &lt;code&gt;combineLatest&lt;/code&gt; takes &lt;code&gt;A&lt;/code&gt; and combines it with the latest element from S1 &lt;code&gt;2&lt;/code&gt;. (&amp;ldquo;What about &lt;code&gt;1&lt;/code&gt;?&amp;rdquo; some of you are asking. Well - tough luck, &lt;code&gt;1&lt;/code&gt; didn&amp;rsquo;t make it.)&lt;/li&gt;
&lt;li&gt;later S2 emits another element &lt;code&gt;B&lt;/code&gt;, again &lt;code&gt;combineLatest&lt;/code&gt; combines it with the latest element from S1, which is &lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and so forth&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;combineLatest&lt;/code&gt; is particularly useful handling UI input (you can react to all changes in any of the UI&amp;rsquo;s text fields, switches, etc) or when you fire a number of networking requests and need to react when any of the http responses completes.&lt;/p&gt;

&lt;h2 id=&#34;using-combinelatest-with-a-dynamic-number-of-source-observables:5c9f9259b42e6e7edba2de9c8047659b&#34;&gt;Using combineLatest with a dynamic number of source observables&lt;/h2&gt;

&lt;p&gt;I created a small example for this article, and added the code to my &lt;a href=&#34;https://github.com/icanzilb/RxSwiftoniOS&#34;&gt;https://github.com/icanzilb/RxSwiftoniOS&lt;/a&gt; repository. If you clone the repo and run it - it&amp;rsquo;s under number 4 in the main menu.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/rxoniosmenu.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re only interested in the code just peak inside here: &lt;a href=&#34;https://github.com/icanzilb/RxSwiftoniOS/blob/master/RxSwiftiOS/CombineViewController.swift&#34;&gt;https://github.com/icanzilb/RxSwiftoniOS/blob/master/RxSwiftiOS/CombineViewController.swift&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the lesser known features of &lt;code&gt;combineLatest&lt;/code&gt; is that you can either use it with a given number of sources (which can be two, three, four, or more but still a fixed number), like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.combineLatest(S1, S2, S3) { value1, value2, value3 in
	print(&amp;quot;latest values: ...&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if you don&amp;rsquo;t know how many sources you have in advance or in case you want to be able to easily map over the emitted values you can also provide a collection of source observables to &lt;code&gt;combineLatest&lt;/code&gt;. Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.combineLatest(sources) { values in
  print(values.map { &amp;quot;value: $0&amp;quot; })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in the example I wrote for this article I&amp;rsquo;m fetching JSON with the list of my followers from GitHub and show them in a collection view. For each follower object in the JSON response I fetch their avatar image and show it in a collection cell.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with fetching the followers JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.just(&amp;quot;https://api.github.com/users/icanzilb/followers&amp;quot;)
  .map { url in
    let apiUrl = URLComponents(string: url)!
    return URLRequest(url: apiUrl.url!)
  }
  .flatMapLatest { request in
    return URLSession.shared.rx.json(request: request)
      .catchErrorJustReturn([])
  }
  .map { json -&amp;gt; [User] in
    guard let users = json as? [JSONObject]  else { return [] }
    return users.flatMap(User.init)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code makes a request to &lt;code&gt;https://api.github.com/users/icanzilb/followers&lt;/code&gt; and gets back a list of JSON objects, then it maps them to an array of &lt;code&gt;User&lt;/code&gt; objects. Each &lt;code&gt;User&lt;/code&gt; has a &lt;code&gt;login&lt;/code&gt; and an &lt;code&gt;avatarUrl&lt;/code&gt; properties.&lt;/p&gt;

&lt;p&gt;I bind the users list to the &lt;code&gt;followers&lt;/code&gt; Variable and will map each user object to an HTTP request, which will fetch their avatar image from GitHub:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;followers.asObservable()
  .map { users -&amp;gt; [Observable&amp;lt;Data&amp;gt;] in
    return users.map { user in
      let request = URLRequest(url: URL(string: user.avatarUrl)!)
      return URLSession.shared.rx.data(request: request)
        .catchErrorJustReturn(UIImage.blank)
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;map&lt;/code&gt; above takes in the list of user objects &lt;code&gt;[User]&lt;/code&gt; and maps those to &lt;code&gt;URLSession&lt;/code&gt; observable responses &lt;code&gt;[Observable&amp;lt;Data&amp;gt;]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Neat! I&amp;rsquo;m passing the array of observables directly to &lt;code&gt;combineLatest&lt;/code&gt; and convert the returned collection of &lt;code&gt;Data&lt;/code&gt; values into images:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.flatMap(Observable.combineLatest)
.map { $0.map(UIImage.fromData) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I had to add a quick extension to &lt;code&gt;UIImage&lt;/code&gt; to add a static method to make images out of data values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension UIImage {
  static func fromData(data: Data) -&amp;gt; UIImage { return UIImage(data: data)! }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice. Now when all my HTTP requests get their response &lt;code&gt;combineLatest&lt;/code&gt; gives me a list of data values, which I turn into images and can bind to a variable or otherwise make use of.&lt;/p&gt;

&lt;p&gt;If you run the linked above demo project you will see that the code fetches all followers from GitHub, then fires off a bunch of requests, gets all their avatars and once that&amp;rsquo;s done it does a single data reload on the collection view and shows them all at once:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/followers-list-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ok, that&amp;rsquo;s all about using &lt;code&gt;combineLatest&lt;/code&gt; with a collection of source sequences. But wait - there&amp;rsquo;s more to be said on the topic &amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;all-at-once-vs-as-they-come:5c9f9259b42e6e7edba2de9c8047659b&#34;&gt;All at once vs. as they come&lt;/h2&gt;

&lt;p&gt;When using &lt;code&gt;combineLatest&lt;/code&gt; (especially with network requests) you might want to have two very different use cases.&lt;/p&gt;

&lt;p&gt;In the example above you saw how to fire simulatenously an arbitrary number of network requests and only once all of them have completed emit the result of all of them.&lt;/p&gt;

&lt;p&gt;But how about if you didn&amp;rsquo;t want ot wait for all requests to complete? What if you preferred to update the UI as each of the requests receives a response?&lt;/p&gt;

&lt;p&gt;Well, remember the discussion above? &lt;code&gt;combineLatest&lt;/code&gt; does emit for each element from the source sequences but &lt;strong&gt;only after all of them have a latest value&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So, I wanted to show that as well in the demo project so you will actually find two different methods in the view controller source code &lt;code&gt;getAllAtOnce()&lt;/code&gt; and &lt;code&gt;getAsTheyCome()&lt;/code&gt;. You can switch between those in the app UI by toggling the segment control at the top of the screen.&lt;/p&gt;

&lt;p&gt;So the only difference in the code of the two methds (and I mean &lt;strong&gt;the only&lt;/strong&gt;) is that when I&amp;rsquo;m reloading the collection whenever each of the avatar requests completes I&amp;rsquo;m providing a default value for each observable.&lt;/p&gt;

&lt;p&gt;So here&amp;rsquo;s the code to fetch &lt;strong&gt;all at once&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.map { users -&amp;gt; [Observable&amp;lt;Data&amp;gt;] in
  return users.map { user in
    let request = URLRequest(url: URL(string: user.avatarUrl)!)
    return URLSession.shared.rx.data(request: request)
      .catchErrorJustReturn(UIImage.blank)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the code that makes &lt;code&gt;combineLatest&lt;/code&gt;&amp;rsquo;s result emit as each response comes in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.map { users -&amp;gt; [Observable&amp;lt;Data&amp;gt;] in
  return users.map { user in
    let request = URLRequest(url: URL(string: user.avatarUrl)!)
    return URLSession.shared.rx.data(request: request)
      .startWith(UIImage.blank)
      .catchErrorJustReturn(UIImage.blank)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, I&amp;rsquo;m sure you spotted the difference - the source has a default value (in my case it&amp;rsquo;s an empty avatar image). This way the collection starts out with a default image for each follower and then as the images are fetched one by one the collection reloads to display each new one. (Yes, not optimal but the point here is to discuss combineLatest.)&lt;/p&gt;

&lt;p&gt;So the screen starts with all sources&amp;rsquo; latest values (at first those are the default images):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/followers-list-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And then you can see how the collection keeps reloading to display each of the received images:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/followers-list-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To try this in the app tap on the &lt;em&gt;As they come&lt;/em&gt; segment on top.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s a wrap!&lt;/p&gt;

&lt;h2 id=&#34;where-to-go-from-here:5c9f9259b42e6e7edba2de9c8047659b&#34;&gt;Where to go from here?&lt;/h2&gt;

&lt;p&gt;Once more, the demo project for this article you will find on GitHub here: &lt;a href=&#34;https://github.com/icanzilb/RxSwiftoniOS&#34;&gt;https://github.com/icanzilb/RxSwiftoniOS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I hope this post has been helpful and has shown you a couple of nice &lt;code&gt;combineLatest&lt;/code&gt; features. Of course these few examples don&amp;rsquo;t cover everything - if you&amp;rsquo;d like to go deeper into combining operators you&amp;rsquo;re welcome to check Chapter 9, &amp;ldquo;Combining Operators&amp;rdquo; and Chapter 10, &amp;ldquo;Combining Operators in Practice&amp;rdquo;, which cover far more ground than this post.&lt;/p&gt;

&lt;p&gt;The book is available at &lt;a href=&#34;https://store.raywenderlich.com/products/rxswift?source=underplot&#34;&gt;http://raywenderlich.com/store&lt;/a&gt; - this is where you can see any updates, discuss in the website forums, etc.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Two free chapters from the RxSwift book!</title>
      <link>http://rx-marin.com/post/rxswift-book-free-chapters/</link>
      <pubDate>Mon, 10 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-book-free-chapters/</guid>
      <description>

&lt;p&gt;Last week we announced our brand new RxSwift book (&lt;a href=&#34;https://store.raywenderlich.com/products/rxswift?source=underplot&#34;&gt;available now&lt;/a&gt;)!&lt;/p&gt;

&lt;p&gt;The book starts with the very basics in Chapter 1, &amp;ldquo;Hello, world!&amp;rdquo; and leads the reader through a plethora of topics all the way to Chapter 23, &amp;ldquo;MVVM&amp;rdquo; and Chapter 24, &amp;ldquo;Building a complete app with RxSwift&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Being so detailed about RxSwift knowledge already sets the book apart as a great learning source, but what is really special is that it&amp;rsquo;s written by four very active RxSwift community memebers and it&amp;rsquo;s polished by two more editors. All in all the quality (apart from some first edition errata, hehe) is very high.&lt;/p&gt;

&lt;p&gt;But don&amp;rsquo;t take my word for it&amp;hellip;&lt;/p&gt;

&lt;p&gt;As part of the launch celebration Ray Wenderlich (the publisher of the book) has released two of the book&amp;rsquo;s chapters for free on his website. So, if you&amp;rsquo;re still trying to make your mind about the quality of the content found inside the book - here&amp;rsquo;s your chance!&lt;/p&gt;

&lt;h2 id=&#34;chapter-7-transforming-operators:a40446abe461214d278199604fa0bc59&#34;&gt;Chapter 7, Transforming Operators&lt;/h2&gt;

&lt;p&gt;In the first half of the book where we cover foundational classes like &lt;code&gt;Observable&lt;/code&gt;, &lt;code&gt;PublishSubject&lt;/code&gt;, &lt;code&gt;Variable&lt;/code&gt;, and most of the operators found in RxSwift, we alternate between theory and &amp;ldquo;&amp;hellip; in practice&amp;rdquo; chapters.&lt;/p&gt;

&lt;p&gt;In the theory chapters we introduce concepts and lead the reader through experimenting in an Xcode playground. This hands on approach to learning has proven to be more fun than just reading theory (I&amp;rsquo;ve worked on a number of books with raywenderlich.com).&lt;/p&gt;

&lt;p&gt;Long story short, in Chapter 7 we&amp;rsquo;re introducing transforming operators and how to use them. The chapter is written by Scott Gardner and takes the readers on a journey through some of the most used operators like: &lt;code&gt;toArray()&lt;/code&gt;, &lt;code&gt;map(_)&lt;/code&gt;, &lt;code&gt;mapWithIndex(_)&lt;/code&gt;, &lt;code&gt;flatMap(_)&lt;/code&gt;, &lt;code&gt;flatMapFirst(_)&lt;/code&gt;, and &lt;code&gt;flatMapLatest(_)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The chapter features some theory, solid explanations with diagrams, and code to try in the provided playground.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/to-array.png&#34; alt=&#34;to array&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can find an abbreviated free version of that chapter here:
&lt;a href=&#34;https://www.raywenderlich.com/158205/rxswift-transforming-operators&#34;&gt;https://www.raywenderlich.com/158205/rxswift-transforming-operators&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;chapter-8-transforming-operators-in-practice:a40446abe461214d278199604fa0bc59&#34;&gt;Chapter 8, Transforming Operators in Practice&lt;/h2&gt;

&lt;p&gt;As with all &amp;ldquo;.. in practice&amp;rdquo; chapters in RxSwift: Reactive programming with Swift, the chapter that follows takes the introduced new concepts and/or operators and leads the reader through a step-by-step tutorial, building up a real iOS project to showcase some real-life usages of the newly introduced concepts.&lt;/p&gt;

&lt;p&gt;Chapter 8, Transforming Operators in Practice leads the reader through building a GitHub activity app. This kind of app, which talks to an online JSON API, processes the response asynchronously, and displays results on screen is the perfect opportunity to use a bunch of transforming operators.&lt;/p&gt;

&lt;p&gt;Even if a little tailored to showcase specifically transforming operators, the project in that chapter can serve as a base to any app that needs to fetch JSON and display the response data on screen, so it&amp;rsquo;s a great excercise in building RxSwift apps.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/github-activity.png&#34; alt=&#34;github activity&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can find an abbreviated free version of that chapter here:
&lt;a href=&#34;https://www.raywenderlich.com/158364/rxswift-transforming-operators-practice&#34;&gt;https://www.raywenderlich.com/158364/rxswift-transforming-operators-practice&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;where-to-buy:a40446abe461214d278199604fa0bc59&#34;&gt;Where to buy?&lt;/h2&gt;

&lt;p&gt;Enjoy those completely free chapters from the book, and we hope you&amp;rsquo;ll enjoy reading the book too!&lt;/p&gt;

&lt;p&gt;The book is available at &lt;a href=&#34;https://store.raywenderlich.com/products/rxswift?source=underplot&#34;&gt;http://raywenderlich.com/store&lt;/a&gt; - this is where you can see any updates, discuss in the website forums, etc. Or of course you can order a print copy for your office bookshelf!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RxSwift book - available now!</title>
      <link>http://rx-marin.com/post/rxswift-book-available-now/</link>
      <pubDate>Mon, 03 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-book-available-now/</guid>
      <description>

&lt;p&gt;After a long time working on this project, I and my friends and colleagues &lt;a href=&#34;https://twitter.com/fpillet&#34;&gt;Florent Pillet&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/bontoJR&#34;&gt;Junior Bontognali&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/scotteg&#34;&gt;Scott Gardner&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/ashfurrow&#34;&gt;Ash Furrow&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/crispytwit&#34;&gt;Chris Belanger&lt;/a&gt;, and &lt;a href=&#34;https://twitter.com/rwenderlich&#34;&gt;Ray&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/vwenderlich&#34;&gt;Vicki&lt;/a&gt; Wenderlich are happy to announce that our new book about development with RxSwift is &lt;a href=&#34;https://store.raywenderlich.com/products/rxswift?source=underplot&#34;&gt;available now&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&#34;how-it-came-to-be:a0d4785814e3d20a5250358d39666ba2&#34;&gt;How it came to be?&lt;/h2&gt;

&lt;p&gt;When I first tried out RxSwift (being excited about it by some of the same people who are my co-authors on the book) I immediately noticed that even though there is plenty of information on the Internet, there isn&amp;rsquo;t a single structured resource where people can learn systematically.&lt;/p&gt;

&lt;p&gt;Almost instantly I started dreaming about creating an RxSwift book that will make beginning development with Rx on iOS easier and more pleasant.&lt;/p&gt;

&lt;p&gt;I met with Junior, Scott, Florent, and Ash in different combinations over a number of conferences and it became clear all of us were working on some education materials in one form or another and the only sensible thing to do is to comibine our efforts!&lt;/p&gt;

&lt;p&gt;At the time Ray Wenderlich has already noticed that RxSwift and Rx are generating a lot of buzz and came with the idea of a book that will take the readers from complete beginner to a professinonal.&lt;/p&gt;

&lt;p&gt;And after some time of very hard work on this, I&amp;rsquo;m proud to announce &amp;hellip; (drumroll) &amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;the-rxswift-book:a0d4785814e3d20a5250358d39666ba2&#34;&gt;The RxSwift book&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://store.raywenderlich.com/products/rxswift?source=underplot&#34;&gt;&lt;img src=&#34;http://rx-marin.com/images/RxSwift-cover.png&#34; alt=&#34;Rxbook cover&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-book-concept:a0d4785814e3d20a5250358d39666ba2&#34;&gt;The book concept&lt;/h3&gt;

&lt;p&gt;The big idea behind this book is to start from the basics and explain how the foundational APIs work and can be used, therefore eliminating any &amp;ldquo;&lt;em&gt;magic&lt;/em&gt;&amp;rdquo; behind using RxSwift.&lt;/p&gt;

&lt;p&gt;We tackle introducing the RxSwift concepts by alterating between theory chapters and practice chapters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;theory chapters&lt;/strong&gt; introduce new APIs and operators and guide the readers through trying out code in an Xcode playground. This way the reader has the context to play with simple code and understand how things really work.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;practice chapters&lt;/strong&gt; feature a starter project and guide the reader through adding RxSwift code in key places to Rx-ify the project, and excercise the newly learned skills in the relevant theory chapter.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we cover the basics like observables, subjects, and operators, the book moves onto more advanced topics like error handling, testing, RxCocoa, and creating custom reactive extensions.&lt;/p&gt;

&lt;p&gt;The last section of the book walks the readers through two complete apps discussing app architecture (there is a separate chapter covering MVVM), app services, project navigation, and more.&lt;/p&gt;

&lt;h3 id=&#34;table-of-contents:a0d4785814e3d20a5250358d39666ba2&#34;&gt;Table of contents&lt;/h3&gt;

&lt;p&gt;The book is divided into six sections. Here’s a brief overview:&lt;/p&gt;

&lt;h4 id=&#34;section-i-getting-started-with-rxswift:a0d4785814e3d20a5250358d39666ba2&#34;&gt;Section I: Getting Started with RxSwift&lt;/h4&gt;

&lt;p&gt;The first section of the book covers RxSwift basics. Don’t skip this section, as you will be required to have a good understanding of how and why things work in the following sections.&lt;/p&gt;

&lt;h4 id=&#34;section-ii-operators-and-best-practices:a0d4785814e3d20a5250358d39666ba2&#34;&gt;Section II: Operators and Best Practices&lt;/h4&gt;

&lt;p&gt;In this section, once you&amp;rsquo;ve mastered the basics, you will move on to building more complex Rx code by using operators. Operators allow you to chain and compose little pieces of functionality to build up complex logic.&lt;/p&gt;

&lt;h4 id=&#34;section-iii-ios-apps-with-rxcocoa:a0d4785814e3d20a5250358d39666ba2&#34;&gt;Section III: iOS Apps with RxCocoa&lt;/h4&gt;

&lt;p&gt;Once you&amp;rsquo;ve mastered RxSwift&amp;rsquo;s basics and know how to use operators, you will move on to iOS specific APIs, which will allow you to use and integrate your RxSwift code with the existing iOS classes and UI controls.&lt;/p&gt;

&lt;h4 id=&#34;section-iv-intermediate-rxswift-rxcocoa:a0d4785814e3d20a5250358d39666ba2&#34;&gt;Section IV: Intermediate RxSwift/RxCocoa&lt;/h4&gt;

&lt;p&gt;In this section, you will look into more topics like building an error handling strategy for your app, handling your networking needs the reactive way, writing Rx tests, and more.&lt;/p&gt;

&lt;h4 id=&#34;section-v-rxswift-community-cookbook:a0d4785814e3d20a5250358d39666ba2&#34;&gt;Section V: RxSwift Community Cookbook&lt;/h4&gt;

&lt;p&gt;Many of the available RxSwift based libraries are created and maintained by the community – by people just like you. In this section, we&amp;rsquo;ll look into a few of these projects and how you can use them in your own apps.&lt;/p&gt;

&lt;h4 id=&#34;section-vi-putting-it-all-together:a0d4785814e3d20a5250358d39666ba2&#34;&gt;Section VI: Putting it All Together&lt;/h4&gt;

&lt;p&gt;This part of the book deals with app architecture and strategies for building production-quality, full-blown iOS applications. You will learn how to structure your project and explore a couple of different approaches to designing your data streams and project navigation.&lt;/p&gt;

&lt;h2 id=&#34;what-s-included:a0d4785814e3d20a5250358d39666ba2&#34;&gt;What&amp;rsquo;s included?&lt;/h2&gt;

&lt;p&gt;You will get to experiment in Playgrounds but also build a number of projects throughout the book:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/rxbook-apps-1.png&#34; alt=&#34;RxSwift book projects&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Like &lt;em&gt;any&lt;/em&gt; raywenderlich.com book you can purchase either a &lt;strong&gt;PDF&lt;/strong&gt; or a &lt;strong&gt;print&lt;/strong&gt; version. Both come with full project source code, split in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;starter projects - your starting point for each chapter.&lt;/li&gt;
&lt;li&gt;final projects - the completed chapter projects as you have them at the end of each chapter.&lt;/li&gt;
&lt;li&gt;challenge projects - the final + some extra excercises you are supposed to complete on your own.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like any other digital raywenderlich.com book - you get &lt;strong&gt;ANY&lt;/strong&gt; further editions of the book &lt;strong&gt;for free&lt;/strong&gt;. Thanks for supporting us!&lt;/p&gt;

&lt;p&gt;Finally, of course you can use the code in any of your projects!&lt;/p&gt;

&lt;p&gt;Thanks again for considering our book and spreading the word about it - we worked very hard on putting this together and it&amp;rsquo;s a product of love, which we hope will be helpful to many who start developing with RxSwift.&lt;/p&gt;

&lt;h2 id=&#34;where-to-buy:a0d4785814e3d20a5250358d39666ba2&#34;&gt;Where to buy?&lt;/h2&gt;

&lt;p&gt;The book is available at &lt;a href=&#34;https://store.raywenderlich.com/products/rxswift?source=underplot&#34;&gt;http://raywenderlich.com/store&lt;/a&gt; - this is where you can see any updates, discuss in the website forums, etc. Or of course you can order a print copy for your office bookshelf!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>(dotSwift) Unidirectional data flow with RxSwift and RxRealm</title>
      <link>http://rx-marin.com/post/dotswift-rxswift-rxrealm-unidirectional-dataflow/</link>
      <pubDate>Fri, 24 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/dotswift-rxswift-rxrealm-unidirectional-dataflow/</guid>
      <description>

&lt;p&gt;In my talk at dotSwift 2017 I start with generic overview of some of the RxSwift basics and move to three complete code examples. In three posts I post the sample code and comment shortly why I chose to highlight these exact examples.&lt;/p&gt;

&lt;p&gt;I already posted a write up on the GitHub API search example here: &lt;a href=&#34;http://rx-marin.com/post/dotswift-search-github-json-api/&#34;&gt;http://rx-marin.com/post/dotswift-search-github-json-api/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The second post in the series, the one about presenting view controllers, is online here: &lt;a href=&#34;http://rx-marin.com/post/dotswift-rxswift-view-controller/&#34;&gt;http://rx-marin.com/post/dotswift-rxswift-view-controller/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s continue with example number three.&lt;/p&gt;

&lt;h2 id=&#34;modelling-unidirectional-data-flow-with-rxrealm:651c147c2ff853de33caa4d4f7fea8c9&#34;&gt;Modelling unidirectional data flow with RxRealm&lt;/h2&gt;

&lt;p&gt;RxSwift doesn&amp;rsquo;t neccessarily force you into one architecture or another, but it really helps you keep flows of data separte. For example, one class working on a background thread will fetch data from a network API and save it to disk, another class will read from disk and bind the UI on screen.&lt;/p&gt;

&lt;p&gt;The two are completely separate and shouldn&amp;rsquo;t intermix.&lt;/p&gt;

&lt;p&gt;In this example I used RxRealm with an online JSON API to show how to fetch JSON, store data on disk, and display it on screen easily with RxSwift and Realm.&lt;/p&gt;

&lt;h3 id=&#34;why-i-chose-this-example:651c147c2ff853de33caa4d4f7fea8c9&#34;&gt;Why I chose this example?&lt;/h3&gt;

&lt;p&gt;To make a point, namely that RxSwift allows you to simplify incredibly not only the code but also the logic of your app by defining clean dataflows.&lt;/p&gt;

&lt;h3 id=&#34;the-sample-code:651c147c2ff853de33caa4d4f7fea8c9&#34;&gt;The sample code&lt;/h3&gt;

&lt;p&gt;In this post I can go into a bit more detail about the complete code than it was reasonable in the talk at the conference. Still keep in mind this was written with the goal to fit in a single slide, so corners were cut big time :)&lt;/p&gt;

&lt;p&gt;The sample uses both RxRealm and RxRealmDataSources (which is a simplified data source library to use with realm).&lt;/p&gt;

&lt;p&gt;The completed project shows a table view, which updates any time new objects are added in the background. The table view displays a list of mocked repository activity items, like so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/unidirectional-completed.png&#34; alt=&#34;completed unidirectional dataflow project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the simple example included in the talk, all code is added in the view controller but of course in real-life this could be split across different classes, frameworks, etc.&lt;/p&gt;

&lt;p&gt;The example defines two data flows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;JSON from API, being converted to objects and stored on disk.&lt;/li&gt;
&lt;li&gt;Objects loaded from disk and bound to a UI table.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;1-converting-and-storing-json:651c147c2ff853de33caa4d4f7fea8c9&#34;&gt;1. Converting and storing JSON&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;SourceControlAPI&lt;/code&gt; is a mocked API class, which periodically provides updates in JSON format. &lt;code&gt;SourceControlAPI.updates()&lt;/code&gt; returns &lt;code&gt;Observable&amp;lt;[String: Any]&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The subscription begins like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SourceControlAPI.updates()
  .observeOn(SerialDispatchQueueScheduler(qos: .background))
  .map(Update.fromOrEmpty)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Via &lt;code&gt;observeOn&lt;/code&gt; I switch the processing of the JSON data to a background thread, and map all the JSON objects to &lt;code&gt;Update&lt;/code&gt; realm objects. &lt;code&gt;fromOrEmpty&lt;/code&gt; is a static method, which takes in a dictionary and populates a new &lt;code&gt;Update&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;Once I have the objects, I can bind the list of newly created objects to &lt;code&gt;add()&lt;/code&gt;, which will add them to the default realm file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.subscribe(Realm.rx.add())
.addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The data flow is simple and linear:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;API -&amp;gt; JSON -&amp;gt; [Update] -&amp;gt; Realm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This happens on a background thread and perisist the data for possible offline use.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s move on to &amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;2-binding-objects-from-disk-to-ui:651c147c2ff853de33caa4d4f7fea8c9&#34;&gt;2. Binding objects from disk to UI&lt;/h4&gt;

&lt;p&gt;This one is even easier thanks to a simple helper library called RxRealmDataSources, which helps binding a Realm collection to a table or collection view on screen.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start by defining a data source object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let dataSource = RxTableViewRealmDataSource&amp;lt;Update&amp;gt;(cellIdentifier: &amp;quot;Cell&amp;quot;, cellType: UITableViewCell.self) {cell, ip, update in
    cell.detailTextLabel!.text = &amp;quot;[&amp;quot; + update.ago + &amp;quot;] &amp;quot; + update.name + &amp;quot; &amp;quot; + update.action
    cell.textLabel?.text = &amp;quot;Repo: &amp;quot; + update.repo
}
dataSource.headerTitle = &amp;quot;Source Control Activity&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines a data source object for &lt;code&gt;Update&lt;/code&gt; objects, which is going to be producing table cells with identifier &amp;ldquo;Cell&amp;rdquo;. It also features a closure to configure each of the cells before it&amp;rsquo;s being used on screen.&lt;/p&gt;

&lt;p&gt;Secondly, let&amp;rsquo;s create the Realm collection to bind:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let realm = try! Realm()
let updates = realm
  .objects(Update.self)
  .sorted(byKeyPath: &amp;quot;date&amp;quot;, ascending: false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;updates&lt;/code&gt; gives access to all &lt;code&gt;Update&lt;/code&gt; objects sorted in descending order by their date property.&lt;/p&gt;

&lt;p&gt;Finally binding the updates to the table view, using the data source is a matter of:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.changeset(from: updates)
  .bindTo(tableView.rx.realmChanges(dataSource))
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This lets RxRealmDataSources piece everything together and drive the UI:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/unidirectional-animation.gif&#34; alt=&#34;table animation&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-complete-example:651c147c2ff853de33caa4d4f7fea8c9&#34;&gt;The complete example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 1. store data
SourceControlAPI.updates()
    .observeOn(SerialDispatchQueueScheduler(qos: .background))
    .map(Update.fromOrEmpty)
    .subscribe(Realm.rx.add())
    .addDisposableTo(bag)

// 2. display data
let dataSource = RxTableViewRealmDataSource&amp;lt;Update&amp;gt;(cellIdentifier: &amp;quot;Cell&amp;quot;, cellType: UITableViewCell.self) {cell, ip, update in
    cell.detailTextLabel!.text = &amp;quot;[&amp;quot; + update.ago + &amp;quot;] &amp;quot; + update.name + &amp;quot; &amp;quot; + update.action
    cell.textLabel?.text = &amp;quot;Repo: &amp;quot; + update.repo
}
dataSource.headerTitle = &amp;quot;Source Control Activity&amp;quot;

let realm = try! Realm()
let updates = realm.objects(Update.self).sorted(byKeyPath: &amp;quot;date&amp;quot;, ascending: false)

Observable.changeset(from: updates)
    .bindTo(tableView.rx.realmChanges(dataSource))
    .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;discussion:651c147c2ff853de33caa4d4f7fea8c9&#34;&gt;Discussion&lt;/h3&gt;

&lt;p&gt;In real life you never have just two data flows in your whole app. But even in this simple example you can see the benefits of being able to clearly and simply define how data flows. Even as you scale your app, the complexity of defining these type of data flows does not increase.&lt;/p&gt;

&lt;p&gt;Hope that was an inspirational read! You can dig into more details below&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Links&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The complete demo app from my talk: &lt;a href=&#34;https://github.com/icanzilb/RxSwiftoniOS&#34;&gt;https://github.com/icanzilb/RxSwiftoniOS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The talk slides: &lt;a href=&#34;https://speakerdeck.com/icanzilb/rxswift-on-ios&#34;&gt;https://speakerdeck.com/icanzilb/rxswift-on-ios&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>(dotSwift) Presenting View Controllers with RxSwift</title>
      <link>http://rx-marin.com/post/dotswift-rxswift-view-controller/</link>
      <pubDate>Tue, 28 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/dotswift-rxswift-view-controller/</guid>
      <description>

&lt;p&gt;In my talk at dotSwift 2017 I start with generic overview of some of the RxSwift basics and move to three complete code examples. In three posts I&amp;rsquo;ll post the sample code and comment shortly why I chose to highlight these exact examples.&lt;/p&gt;

&lt;p&gt;I already posted a write up on the GitHub API search example here: &lt;a href=&#34;http://rx-marin.com/post/dotswift-search-github-json-api/&#34;&gt;http://rx-marin.com/post/dotswift-search-github-json-api/&lt;/a&gt;. Let&amp;rsquo;s continue with example number two.&lt;/p&gt;

&lt;h2 id=&#34;presenting-a-view-controller-from-rxswift:cf33baac886ac7ae000310d0f0e5995d&#34;&gt;Presenting a View Controller from RxSwift&lt;/h2&gt;

&lt;p&gt;RxSwift doesn&amp;rsquo;t neccessarily force you into one architecture or another, it&amp;rsquo;s really up to you to chose how are you going to structure your application. Same goes for navigation and how you move the user between your app&amp;rsquo;s screens and different view controllers.&lt;/p&gt;

&lt;h3 id=&#34;why-i-chose-this-example:cf33baac886ac7ae000310d0f0e5995d&#34;&gt;Why I chose this example?&lt;/h3&gt;

&lt;p&gt;To make a point, namely that RxSwift plays very nicely with UIKit when neccessary, I chose to demo a simple code to present a view controller, get data back from that view controller, and navigate back to the presenting controller.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a simple demo but demonstrates well one of the biggest benefits of using RxSwift - obliterating the need to deal with delegate to simply communicate between classes.&lt;/p&gt;

&lt;h3 id=&#34;the-sample-code:cf33baac886ac7ae000310d0f0e5995d&#34;&gt;The sample code&lt;/h3&gt;

&lt;p&gt;In this post I can go in a bit more detail about the complete code than it was reasonable in the talk at the conference. Still keep in mind this was written with the goal to fit in a single slide, so corners were cut big time :) And so let&amp;rsquo;s get started.&lt;/p&gt;

&lt;p&gt;The example is ultimately about an app featuring two view controllers:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A list of GitHub repos (stored in an array), displayed in a table view.&lt;/li&gt;
&lt;li&gt;A modal view controller, which allows the user to add a new repo to the list.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s first have a look at the list view controller. The repos are stored in a variable (for the purpose to simplify the example):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private let repos = Variable&amp;lt;[Repo]&amp;gt;(initialRepos)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the initial values are just a list of &lt;code&gt;Repo&lt;/code&gt; objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private let initialRepos = [
    Repo(1, &amp;quot;EasyAnimation&amp;quot;, &amp;quot;Swift&amp;quot;),
    Repo(2, &amp;quot;Unbox&amp;quot;, &amp;quot;Swift&amp;quot;),
    Repo(3, &amp;quot;RxSwift&amp;quot;, &amp;quot;Swift&amp;quot;)
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;repos&lt;/code&gt; are bound to the table view as usual via RxDataSources:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;repos.asObservable()
  .bindTo(tableView.rx.items) { (tableView, row, repo) in
    let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;Cell&amp;quot;)!
    cell.textLabel!.text = repo.name
    cell.detailTextLabel?.text = repo.language
    return cell
  }
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, to present a view controller with RxSwift, we&amp;rsquo;ll react to navigation item taps and, once pushed the view controller to the navigation stack, we&amp;rsquo;ll subscribe an observable on the presented controller. That observable will emit a next event and complete once the user has finished working with it.&lt;/p&gt;

&lt;p&gt;We start with subscribing for taps:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;navigationItem.rightBarButtonItem!.rx.tap
  .throttle(0.5, latest: false, scheduler: MainScheduler.instance)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bu using &lt;code&gt;throttle&lt;/code&gt; we&amp;rsquo;ll ignore any unintentional double taps (and avoid presenting more than one copy of the view controller one over each other).&lt;/p&gt;

&lt;p&gt;Next we need to &amp;ldquo;kind of wait&amp;rdquo; until the observable of the view controller completes and get the data it emitted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.flatMapFirst {[weak self] _ -&amp;gt; Observable&amp;lt;Repo&amp;gt; in
  if let addVC = self?.storyboard?.instantiateViewController(withIdentifier: &amp;quot;NewRepoViewController&amp;quot;) 
  as? NewRepoViewController {
    self?.navigationController?.pushViewController(addVC, animated: true)
    return addVC.repoObservable
  }
  return Observable.never()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The block we provide to &lt;code&gt;flatMap&lt;/code&gt; fetches the view controller from a storyboard and pushes it onto the navigation stack. Once presented, we return the &lt;code&gt;repoObservable&lt;/code&gt; public property of the presented view controller.&lt;/p&gt;

&lt;p&gt;That observable is going to give us back a &lt;code&gt;Repo&lt;/code&gt; object in case the user has successfully created a new one. Once we have a &lt;code&gt;Repo&lt;/code&gt; we can add it to the list and let the Rx binding from earlier update the table view.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll subscribe the result and update the list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.subscribe(onNext: {[weak self] repo in
  self?.repos.value.append(repo)
  _ = self?.navigationController?.popViewController(animated: true)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we know the observable is going to emit exactly one event, we also pop the view controller from the navigation stack. And that&amp;rsquo;s pretty much it! We present the controller, it gives us back data via a next event, and when it completes we discard it. Neat!&lt;/p&gt;

&lt;p&gt;Now just for kicks have a look also at the code of the presented controller. The new repo controller exposes the user data via an observable like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private let repo = PublishSubject&amp;lt;Repo&amp;gt;()

lazy var repoObservable: Observable&amp;lt;Repo&amp;gt; = {
  return self.repo.asObservable()
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The controller itself can use the private &lt;code&gt;repo&lt;/code&gt; subject to emit events, and other classes can subscribe to the &lt;code&gt;repoObservable&lt;/code&gt; and react to events.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s firstly combine all text values and make a &lt;code&gt;Repo&lt;/code&gt; of them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// current repo data
let currentRepo = Observable.combineLatest(
  id.rx.text, name.rx.text, language.rx.text) { id, name, lang -&amp;gt; Repo? in

  guard let id = id, let idInt = Int(id),
    let name = name, name.characters.count &amp;gt; 1,
    let lang = lang, lang.characters.count &amp;gt; 0 else {
      return nil
    }
    return Repo(idInt, name, lang)
  }
  .shareReplay(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We combine the sequence of values from the text fields &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;language&lt;/code&gt; and after a simple validation routine we emit a &lt;code&gt;Repo&lt;/code&gt; object. The first subscription to &lt;code&gt;currentRepo&lt;/code&gt; will update the UI:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// toggle save button
currentRepo
  .map { $0 != nil }
  .bindTo(saveButton.rx.isEnabled)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user&amp;rsquo;s input produces a valid &lt;code&gt;Repo&lt;/code&gt; object, the save button is enabled so the user can add it to the list of existing repos. Next we&amp;rsquo;ll observe for taps on the Save bar item:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// emit repo when saved
saveButton.rx.tap
  .withLatestFrom(currentRepo)
  .subscribe(onNext: {[weak self] repo in
    if let repo = repo {
      self?.repo.onNext(repo)
      self?.repo.onCompleted()
    }
  })
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever the user taps the save button we grab the latest value of &lt;code&gt;currentRepo&lt;/code&gt; and in the subscribe block, we emit it from the &lt;code&gt;repo&lt;/code&gt; subjects. Any subscribers to &lt;code&gt;repoObservable&lt;/code&gt; will get the event and dispose afterwards.&lt;/p&gt;

&lt;p&gt;And there you go - with few lines of code in both view controllers you move away from the delegate pattern, which could be useful in some cases but your code ends up defining and implementing tons of protocols and as always it&amp;rsquo;s very hard to argue about the sequence in which methods are executed.&lt;/p&gt;

&lt;p&gt;Through the use of the &lt;code&gt;Observable&lt;/code&gt; class, you saw that the two view controllers can talk to each without the need of creating extra entities, protocols, etc.&lt;/p&gt;

&lt;h3 id=&#34;the-complete-example:cf33baac886ac7ae000310d0f0e5995d&#34;&gt;The complete example&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;PresentViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func bindUI() {
  // display data
  repos.asObservable()
    .bindTo(tableView.rx.items) { (tableView, row, repo) in
      let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;Cell&amp;quot;)!
      cell.textLabel!.text = repo.name
      cell.detailTextLabel?.text = repo.language
      return cell
    }
    .addDisposableTo(bag)

  // present view controller, observe output
  navigationItem.rightBarButtonItem!.rx.tap
    .throttle(0.5, latest: false, scheduler: MainScheduler.instance)
    .flatMapFirst {[weak self] _ -&amp;gt; Observable&amp;lt;Repo&amp;gt; in
      if let addVC = self?.storyboard?.instantiateViewController(withIdentifier: &amp;quot;NewRepoViewController&amp;quot;) as? NewRepoViewController {
        self?.navigationController?.pushViewController(addVC, animated: true)
        return addVC.repoObservable
      }
      return Observable.never()
    }
    .subscribe(onNext: {[weak self] repo in
      self?.repos.value.append(repo)
      _ = self?.navigationController?.popViewController(animated: true)
    })
    .addDisposableTo(bag)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NewRepoViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func bindUI() {
  // current repo data
  let currentRepo = Observable.combineLatest(id.rx.text, name.rx.text, language.rx.text) { id, name, lang -&amp;gt; Repo? in
    guard let id = id, let idInt = Int(id),
      let name = name, name.characters.count &amp;gt; 1,
      let lang = lang, lang.characters.count &amp;gt; 0 else {
        return nil
    }
    return Repo(idInt, name, lang)
    }
    .shareReplay(1)

  // toggle save button
  currentRepo
    .map { $0 != nil }
    .bindTo(saveButton.rx.isEnabled)
    .addDisposableTo(bag)

  // emit repo when saved
  saveButton.rx.tap
    .withLatestFrom(currentRepo)
    .subscribe(onNext: {[weak self] repo in
      if let repo = repo {
        self?.repo.onNext(repo)
        self?.repo.onCompleted()
      }
    })
    .addDisposableTo(bag)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;discussion:cf33baac886ac7ae000310d0f0e5995d&#34;&gt;Discussion&lt;/h3&gt;

&lt;p&gt;In real life you will probably never have the the whole presentation logic in one code chain like this. As said the idea above was to fit the code in a single slide and the audience to understand what&amp;rsquo;s happening without previous RxSwift knowledge.&lt;/p&gt;

&lt;p&gt;But hey - it&amp;rsquo;s nice to know you can do that :) And once you know how the code works you can go about splitting the responsibilities of digging through the storyboard, presenting, and making use of the returned data into separate classes.&lt;/p&gt;

&lt;p&gt;Hope that was an inspiration read! You can dig into more details below&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Links&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The complete demo app from my talk: &lt;a href=&#34;https://github.com/icanzilb/RxSwiftoniOS&#34;&gt;https://github.com/icanzilb/RxSwiftoniOS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The talk slides: &lt;a href=&#34;https://speakerdeck.com/icanzilb/rxswift-on-ios&#34;&gt;https://speakerdeck.com/icanzilb/rxswift-on-ios&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>(dotSwift) Search GitHub with RxSwift</title>
      <link>http://rx-marin.com/post/dotswift-search-github-json-api/</link>
      <pubDate>Fri, 27 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/dotswift-search-github-json-api/</guid>
      <description>

&lt;p&gt;In my talk at dotSwift 2017 I start with generic overview of some of the RxSwift basics and move to three complete code examples. In three posts I&amp;rsquo;ll post the sample code and comment shortly why I chose to highlight these exact examples. Let&amp;rsquo;s start with number one.&lt;/p&gt;

&lt;h2 id=&#34;searching-for-github-repositories-with-rxswift:12a67f24277565fb21fc7919261596a9&#34;&gt;Searching for GitHub repositories with RxSwift&lt;/h2&gt;

&lt;p&gt;The first example in the talk is a simple single-screen application that allows the user to enter a repository name (or part of it) and search GitHub for matching results.&lt;/p&gt;

&lt;p&gt;The completed application looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rx-marin.com/images/github-search.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;why-i-chose-this-example:12a67f24277565fb21fc7919261596a9&#34;&gt;Why I chose this example?&lt;/h3&gt;

&lt;p&gt;One of the main points I make in my talk is that Rx and RxSwift in particular solves in big part the pains of asynchronous programming. Cocoa and the iOS SDK offers us a lot of different tools to battle asynchronos flows but there is no standard and we end up using many different (if not all) of these APIs. It&amp;rsquo;s not rare in complex app to use all of NotificationCenter, Grand Central Dispatch, closures, delegates, and more.&lt;/p&gt;

&lt;p&gt;RxSwift solves this by offering a single standard protocol for asynchronous communication between any classes in the app - &lt;code&gt;Observable&lt;/code&gt;. And this is what I wanted to demonstrate with the first example - how a rather diverse workflow that would usually be very complex, involving delegates and closures, becomes very simple to read, and sequential to write.&lt;/p&gt;

&lt;h3 id=&#34;the-sample-code:12a67f24277565fb21fc7919261596a9&#34;&gt;The sample code&lt;/h3&gt;

&lt;p&gt;The example starts with observing the text of a &lt;code&gt;UITextField&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;searchBar.rx.text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The issue with &lt;code&gt;rx.text&lt;/code&gt; is that it emits &lt;code&gt;String?&lt;/code&gt; since the field value is &lt;code&gt;nil&lt;/code&gt; when there&amp;rsquo;s no text inside (Thanks, Obama). Luckily there&amp;rsquo;s an operator called &lt;code&gt;orEmpty&lt;/code&gt;, which converts an optional &lt;code&gt;nil&lt;/code&gt; to unwrapped default value. So for &lt;code&gt;String?&lt;/code&gt; it returns &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; (a non-optional empty string).&lt;/p&gt;

&lt;p&gt;Chained to the previous code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.orEmpty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This maps the observable to &lt;code&gt;Observable&amp;lt;String&amp;gt;&lt;/code&gt;. Neat!&lt;/p&gt;

&lt;p&gt;Next we want to filter search queries too short to be useful that will produce too many and rather irrelevant results. We chain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.filter { query in
  return query.characters.count &amp;gt; 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will discard any searches for less than three characters. Next let&amp;rsquo;s discard any values emitted too fast, we don&amp;rsquo;t need to send all the network requests to GitHub&amp;rsquo;s server on each typed character if the user is typing fast. Chain to the previous code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.debounce(0.5, scheduler: MainScheduler.instance)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user types and then stops for more than half a second, &lt;code&gt;debounce&lt;/code&gt; will let through only the latest value before the user stopped typing. Ok it&amp;rsquo;s time to convert the search query into a web request:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.map { query in
  var apiUrl = URLComponents(string: &amp;quot;https://api.github.com/search/repositories&amp;quot;)!
  apiUrl.queryItems = [URLQueryItem(name: &amp;quot;q&amp;quot;, value: query)]
  return URLRequest(url: apiUrl.url!)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We build a &lt;code&gt;URL&lt;/code&gt; and a &lt;code&gt;URLRequest&lt;/code&gt;, which is ready to be sent to GitHub&amp;rsquo;s server. This &lt;code&gt;map&lt;/code&gt; converts the observable to an &lt;code&gt;Observable&amp;lt;URLRequest&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now by using the built-in reactive extension on &lt;code&gt;URLSession&lt;/code&gt; we can get back the server response in JSON form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.flatMapLatest { request in
  return URLSession.shared.rx.json(request: request)
    .catchErrorJustReturn([])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case there was an error reaching out to the server, &lt;code&gt;catchErrorJustReturn&lt;/code&gt; will make &lt;code&gt;flatMapLatest&lt;/code&gt; return an empty array &lt;code&gt;[]&lt;/code&gt; instead of erroring out. This converts the observable type to &lt;code&gt;Observable&amp;lt;Any&amp;gt;&lt;/code&gt;. So we got the JSON &amp;hellip; What next? Dig inside, find any returned repos and convert the data into objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.map { json -&amp;gt; [Repo] in
  guard let json = json as? [String: Any],
    let items = json[&amp;quot;items&amp;quot;] as? [[String: Any]]  else {
      return []
  }
  return items.flatMap(Repo.init)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;flatMap&lt;/code&gt; on the &lt;code&gt;items&lt;/code&gt; collection will discard any objects that didn&amp;rsquo;t convert propertly to &lt;code&gt;Repo&lt;/code&gt; objects. This final map converts the reponse to an &lt;code&gt;Observable&amp;lt;[Repo]&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We now have the desired outcome - a list of &lt;code&gt;Repo&lt;/code&gt; objects. It&amp;rsquo;s time to show them in the view controller&amp;rsquo;s table view. Using &lt;code&gt;RxCocoa&lt;/code&gt;&amp;rsquo;s &lt;code&gt;bindTo&lt;/code&gt; binding the repos is a matter of few more lines:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.bindTo(tableView.rx.items) { tableView, row, repo in
    let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;Cell&amp;quot;)!
    cell.textLabel!.text = repo.name
    cell.detailTextLabel?.text = repo.language
    return cell
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The operator binds the list of &lt;code&gt;Repo&lt;/code&gt; objects to the table&amp;rsquo;s &lt;code&gt;rx.items&lt;/code&gt;. In the closure parameter you provide the code to deque and configure cells for the table.&lt;/p&gt;

&lt;p&gt;If you want more advanced table binding (e.g. using animations, sections, and more) check out the &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxDataSources&#34;&gt;&lt;code&gt;RxDataSources&lt;/code&gt;&lt;/a&gt; library, which provides many different choices. If you&amp;rsquo;re working with Realm objects, there is a special library that allows you to use row animations and more automatically called &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxRealmDataSources&#34;&gt;&lt;code&gt;RxRealmDataSources&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-complete-example:12a67f24277565fb21fc7919261596a9&#34;&gt;The complete example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;searchBar.rx.text
  .orEmpty
  .filter { query in
    return query.characters.count &amp;gt; 2
  }
  .debounce(0.5, scheduler: MainScheduler.instance)
  .map { query in
    let apiUrl = URL(string: &amp;quot;https://api.github.com/search/repositories?q=&amp;quot; + query)!
    return URLRequest(url: apiUrl)
  }
  .flatMapLatest { request in
    return URLSession.shared.rx.json(request: request)
      .catchErrorJustReturn([])
  }
  .map { json -&amp;gt; [Repo] in
    guard let json = json as? [String: Any],
      let items = json[&amp;quot;items&amp;quot;] as? [[String: Any]]  else {
        return []
    }
    return items.flatMap(Repo.init)
  }
  .bindTo(tableView.rx.items) { tableView, row, repo in
    let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;Cell&amp;quot;)!
    cell.textLabel!.text = repo.name
    cell.detailTextLabel?.text = repo.language
    return cell
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;discussion:12a67f24277565fb21fc7919261596a9&#34;&gt;Discussion&lt;/h3&gt;

&lt;p&gt;In real life you will probably never have the app&amp;rsquo;s logic layed out like this in one single line of code. (You might if you so desire; of course)&lt;/p&gt;

&lt;p&gt;In a full-blown app you will have a networking layer, data layer, etc. You are likely to split this long chain of operators in two or three parts depending on what architecture you use.&lt;/p&gt;

&lt;p&gt;In any case, following the Cocoa patterns you will have one delegate for the text field, one data source for the table, and &lt;code&gt;URLSession&lt;/code&gt; will work with an asynchronous callback closure. The code is split into chunks, and you as the developer need to  always keep in mind the sequence in which these methods will get called as to not corrupt the app state.&lt;/p&gt;

&lt;p&gt;With RxSwift the code is easier to understand because it reads sequentially. Further it&amp;rsquo;s very easy to argue about the order in which code is executed even if it&amp;rsquo;s being executed asynchronously.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Links&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The complete demo app from my talk: &lt;a href=&#34;https://github.com/icanzilb/RxSwiftoniOS&#34;&gt;https://github.com/icanzilb/RxSwiftoniOS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The talk slides: &lt;a href=&#34;https://speakerdeck.com/icanzilb/rxswift-on-ios&#34;&gt;https://speakerdeck.com/icanzilb/rxswift-on-ios&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A smarter Retry with RxSwiftExt</title>
      <link>http://rx-marin.com/post/rxswift-retry-with-delay/</link>
      <pubDate>Sun, 08 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-retry-with-delay/</guid>
      <description>

&lt;p&gt;Sometimes your observable will fail with an error but that would not mean that you need to give up trying. For example saving to a file might fail because the file is locked temporarily but a split second later would be unlocked and ready for your changes. Same goes for web requests - there might be a temporary glitch in connectivity which could make the observable fail.&lt;/p&gt;

&lt;p&gt;RxSwift offers a special operator called &lt;code&gt;retry&lt;/code&gt;, which allows you to try another time the observable subscription upon error.&lt;/p&gt;

&lt;p&gt;You can even tell &lt;code&gt;retry&lt;/code&gt; how many times to keep trying, which is very useful. The code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;responseObservable.retry(3)
  .subscribe(onNext: {next in
    print(&amp;quot;next: \(next)&amp;quot;)
  }, onError: { error in
    print(&amp;quot;error: &amp;quot;)
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case &lt;code&gt;responseObservable&lt;/code&gt; fails, the subscription will &amp;ldquo;&lt;em&gt;restart&lt;/em&gt;&amp;rdquo; up to 3 times and in case it fails all 3 times, it will error out.&lt;/p&gt;

&lt;p&gt;As useful as the built-in operator is - you rarely can solve a real problem by retrying immediately.&lt;/p&gt;

&lt;p&gt;Especially in problems caused by lack of connectivity (and others of course) it&amp;rsquo;s much more useful to wait a little and then retry, hoping that meanwhile the problem was resolved.&lt;/p&gt;

&lt;p&gt;Sometimes it even makes sense to first wait a short interval of time, and after few fails wait longer and longer before retrying.&lt;/p&gt;

&lt;p&gt;There is no built-in &lt;code&gt;retry&lt;/code&gt; operator that will allow you to do that, but you could give a try to &lt;code&gt;RxSwiftExt&lt;/code&gt; - an extra set of operators developed by the community (maintainer of the library is &lt;a href=&#34;https://github.com/fpillet&#34;&gt;fpillet&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;You can have a look at all of the operators included in RxSwiftExt in its README: &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxSwiftExt&#34;&gt;https://github.com/RxSwiftCommunity/RxSwiftExt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After you include (via CocoaPods or Carthage) RxSwiftExt in your project you have few options how to use the smarter &lt;code&gt;retry&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;The smarter &lt;code&gt;retry&lt;/code&gt; takes in a parameter of the &lt;code&gt;RepeatBehavior&lt;/code&gt; enum, which can be one of these four types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;immediate (maxCount:)&lt;/code&gt; - similar to the built-in behavior&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delayed (maxCount:time:)&lt;/code&gt; - retries up to &lt;code&gt;maxCount&lt;/code&gt; times, but with &lt;code&gt;time&lt;/code&gt; amount of seconds between retries&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exponentialDelayed (maxCount:initial:multiplier:)&lt;/code&gt; - retries up to &lt;code&gt;maxCount&lt;/code&gt; times, starts with &lt;code&gt;initial&lt;/code&gt; amount of seconds but uses &lt;code&gt;multiplier&lt;/code&gt; to increase the delay between retries.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;customTimerDelayed(max:delayCalculator:)&lt;/code&gt; - retries up to &lt;code&gt;max&lt;/code&gt; times. &lt;code&gt;delayCalculator&lt;/code&gt; is a closure that gets as input the number of retries so far, and returns how much seconds to wait before trying again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As an extra functionality you can add a closure that evaluates on each retry whether the operator shoud keep trying at all.&lt;/p&gt;

&lt;h3 id=&#34;retrying-at-equal-intervals:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Retrying at equal intervals&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;responseObservable.retry(.delayed(maxCount: 3, time: 5.0),
 shouldRetry: {error in
  return 50..&amp;lt;80 ~= (error as NSError).code
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a more elaborate example so let&amp;rsquo;s have a look. If &lt;code&gt;responseObservable&lt;/code&gt; emits an error &lt;code&gt;retry&lt;/code&gt; will try up to 3 times, with 5 second intervals between the retries.&lt;/p&gt;

&lt;p&gt;Additionally between retries &lt;code&gt;retry&lt;/code&gt; will consult with the &lt;code&gt;shouldRetry&lt;/code&gt; closure if it should keep going. Once the code casts &lt;code&gt;error&lt;/code&gt; as an &lt;code&gt;NSError&lt;/code&gt;, it checks the code of the error. It lets &lt;code&gt;retry&lt;/code&gt; keep trying if the error code is between 50 and 80, and stops retrying if the code is not in that range.&lt;/p&gt;

&lt;p&gt;In your own app return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on your business logic.&lt;/p&gt;

&lt;h3 id=&#34;retrying-in-increasing-intervals:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Retrying in increasing intervals&lt;/h3&gt;

&lt;p&gt;The formula calculting the delay between retries is &lt;code&gt;initial * pow(1 + multiplier, Double(currentRepetition - 1))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;retry(.exponentialDelayed(maxCount: 3, initial: 2.0, multiplier: 1.5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The delay between first and second tries is 2.0 seconds (the value of &lt;code&gt;initial&lt;/code&gt; parameter). Then between second and third tries is 5.0 seconds - &lt;code&gt;2.0 * 2.5&lt;/code&gt; seconds.&lt;/p&gt;

&lt;h3 id=&#34;calculating-the-delay:0d2f3d508498ad2374296c16265dc39a&#34;&gt;Calculating the delay&lt;/h3&gt;

&lt;p&gt;In the end  - if you go for a custom calculator you can simply return any value based on any kind of custom business logic so sky is pretty much the limit.&lt;/p&gt;

&lt;p&gt;As an example here is a piece of code that implements decreasing delays between tries: 10, 9, 8, 7, 6, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let speedUp: (UInt) -&amp;gt; Double = {retries in
  return max(0.0, 10 - Double(retries))
}

responseObservable.retry(.customTimerDelayed(maxCount: 10,
  delayCalculator: speedUp))
    .subscribe()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-non-rxswift-retry:0d2f3d508498ad2374296c16265dc39a&#34;&gt;A non RxSwift retry&lt;/h3&gt;

&lt;p&gt;As a fun bonus, I&amp;rsquo;ve made a &lt;code&gt;retry&lt;/code&gt; library which doesn&amp;rsquo;t use RxSwift at all as I find a custom-delay &lt;code&gt;retry&lt;/code&gt; very useful in all kinds of apps. You can use the pure Swift &lt;code&gt;retry&lt;/code&gt; in a very similar manner: &lt;a href=&#34;https://github.com/icanzilb/retry&#34;&gt;https://github.com/icanzilb/retry&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing your RxSwift code, part 2</title>
      <link>http://rx-marin.com/post/rxswift-rxtests-unit-tests-part-2/</link>
      <pubDate>Mon, 23 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxtests-unit-tests-part-2/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxtests-unit-tests/&#34;&gt;part 1&lt;/a&gt; I looked into writing very basic tests with RxSwift and life was good. But then I wanted to do more and moved on to writing asynchronous tests&amp;hellip;&lt;/p&gt;

&lt;p&gt;I contributed the code for RxRealm - the Rx extension for RealmSwift owned by the RxSwiftCommunity. For RxRealm I needed some asynchronous tests because Realm&amp;rsquo;s collections emit notifications (which RxRealm wraps) when the underlaying data changes.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look at some of the unit tests I wrote&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;asynchronous-tests:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Asynchronous tests&lt;/h2&gt;

&lt;p&gt;First of all I needed to look into writing asynchronous tests - luckily this is quite easy. The basic structure of such a test is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testSomething() {
  let expectation1 = expectationWithDescription(&amp;quot;First event&amp;quot;)
  let expectation2 = expectationWithDescription(&amp;quot;Second event&amp;quot;)

  ... whatever code you need to perform the test ... 
  
  someAsyncAPI(didComplete: {
    expectation1.fulfill()
  })

  someOtherAsyncAPI(didComplete: {
    expectation2.fulfill()
  })
  
  waitForExpectationsWithTimeout(1.0) {error in
     XCTAssertTrue(error == nil)
     ... more asserts ... 
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at what this code does:
 * you need to define all the expectations you&amp;rsquo;d like this test to wait for before it completes; the string argument is decorative,
 * whenever the events you are waiting for complete you call &lt;code&gt;fulfill()&lt;/code&gt; on your expectations,
 * finally you need to define a block to be executed when &lt;strong&gt;ALL&lt;/strong&gt; the expectations are fulfilled; &lt;code&gt;waitForExpectationsWithTimeout&lt;/code&gt; &amp;rsquo;s first parameter is a timeout, which will force the block to execute if the expectations do not fulfill in time.&lt;/p&gt;

&lt;h2 id=&#34;combine-testscheduler-and-async-tests:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Combine TestScheduler and async tests&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s look at a complete test from the RxRealm test suite.&lt;/p&gt;

&lt;p&gt;First I start by defining a single expectation - my expectation will be that a precise number of events were emitted by the observable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;    
func testResultsTypeChangeset() {
    let expectation1 = expectationWithDescription(&amp;quot;Results&amp;quot;)

    let realm = realmInMemory(#function)
    clearRealm(realm)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally I use two of my helper methods to grab a reference to an in-memory realm and clear all objects that might&amp;rsquo;ve been stored inside by other tests in the suite.&lt;/p&gt;

&lt;p&gt;Now just like in Part 1 I define a dispose bag and a test scheduler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let bag = DisposeBag()
        
let scheduler = TestScheduler(initialClock: 0)
let observer = scheduler.createObserver(String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I&amp;rsquo;ll be observing a sequence of &lt;code&gt;String&lt;/code&gt;s - you&amp;rsquo;ll see why in a minute.&lt;/p&gt;

&lt;h2 id=&#34;fulfilling-expectations:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Fulfilling expectations&lt;/h2&gt;

&lt;p&gt;Next I need to create a &lt;code&gt;Results&lt;/code&gt; object since I&amp;rsquo;m going to be testing &lt;code&gt;Results.asObservable()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let messages$ = realm.objects(Message).asObservableChangeset().shareReplay(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m observing all &lt;code&gt;Message&lt;/code&gt; objects stored in my realm.&lt;/p&gt;

&lt;p&gt;Now comes the interesting part - first I&amp;rsquo;ll define when my expectation is fulfilled:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;messages$
  .scan(0, accumulator: {acc, _ in return acc+1})
  .filter { $0 == 3 }
  .map {_ in ()}
  .subscribeNext(expectation1.fulfill)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use &lt;code&gt;scan&lt;/code&gt; to count the emitted values from my observable, &lt;code&gt;filter&lt;/code&gt; helps me to pinpoint in which value I&amp;rsquo;m interested (the 3rd event), I map the value to &lt;code&gt;Void&lt;/code&gt; and subscribe to &lt;code&gt;expectation1.fulfill()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Long story short - when &lt;code&gt;messages$&lt;/code&gt; emits its 3rd event my expectation will fulfill. Neat!&lt;/p&gt;

&lt;p&gt;Since I&amp;rsquo;m not interested in just how many events are emitted but also which events were emitted, I need yet another subscription:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;messages$
  .map {results, changes in
    if let changes = changes {
      return &amp;quot;i:\(changes.inserted) d:\(changes.deleted) u:\(changes.updated)&amp;quot;
    } else {
      return &amp;quot;initial&amp;quot;
    }
  }
  .subscribe(observer)
  .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it&amp;rsquo;s an update event I return a string with the collection indexes that were deleted or inserted, it looks like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i:[0] u:[] d:[1,2,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This logs all the information about the particular change-set that I&amp;rsquo;m interested in (and need to verify if the observable emitted the information I expected).&lt;/p&gt;

&lt;p&gt;If it&amp;rsquo;s the initial event for that collection I just return &amp;ldquo;initial&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;triggering-some-observable-values:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Triggering some Observable values&lt;/h2&gt;

&lt;p&gt;Now I can start the test scheduler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;scheduler.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, ultimately, perform some operations on my Realm to produce change notifications:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;delay(0.1) {
  try! realm.write {
    realm.add(Message(&amp;quot;first&amp;quot;))
  }
}
delay(0.2) {
  try! realm.write {
    realm.delete(realm.objects(Message).first!)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above adds a new object and after a bit of delay deletes it again. This should produce the 3 events I&amp;rsquo;m expecting: the initial data, the insert notification and the deletion notification.&lt;/p&gt;

&lt;h2 id=&#34;verifying-the-recorded-events-with-asserts:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Verifying the recorded events with asserts&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s time to (finally) add my asserts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;waitForExpectationsWithTimeout(0.5) {error in
    //do tests here
    
    XCTAssertTrue(error == nil)
    XCTAssertEqual(observer.events.count, 3)
    XCTAssertEqual(observer.events[0].value.element!, &amp;quot;initial&amp;quot;)
    XCTAssertEqual(observer.events[1].value.element!, &amp;quot;i:[0] d:[] u:[]&amp;quot;)
    XCTAssertEqual(observer.events[2].value.element!, &amp;quot;i:[] d:[0] u:[]&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the block I perform a number of asserts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;no error happened while fulfilling my expectations&lt;/li&gt;
&lt;li&gt;the test observer logged exactly 3 events&lt;/li&gt;
&lt;li&gt;the first emitted value is &amp;ldquo;initial&amp;rdquo;&lt;/li&gt;
&lt;li&gt;the second value is about inserting a value at index 0&lt;/li&gt;
&lt;li&gt;the third value is about deleting a value at index 0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion:5067dfc287a0dc48087ee659edca0c51&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s amazing how easy writing tests is even when testing two completely de-coupled libraries working together like RealmSwift and RxSwift. As you saw it&amp;rsquo;s a matter of 10-20 lines of code depending on your setup and I&amp;rsquo;m sure the code can be simplified even more.&lt;/p&gt;

&lt;p&gt;If you want to read through the complete test suite for RxRealm head to the GitHub repo test folder: &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxRealm/tree/master/Example/RxRealm_Tests&#34;&gt;RxRealm_Tests&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I hope this post has been useful! Do you know a better way to do any of this? Seen a bug? Ping me on Twitter at &lt;a href=&#34;https://twitter.com/icanzilb&#34;&gt;icanzilb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing your RxSwift code, part 1</title>
      <link>http://rx-marin.com/post/rxswift-rxtests-unit-tests/</link>
      <pubDate>Tue, 03 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxtests-unit-tests/</guid>
      <description>

&lt;p&gt;I sat down recently and learned the basics of writing unit tests for RxSwift. It was way easier than I expected and that&amp;rsquo;s why I&amp;rsquo;d like to show few of the tests I got to write.&lt;/p&gt;

&lt;p&gt;Before I start on the code itself I just want to mention how great contributing to open source is. If I didn&amp;rsquo;t jump in to helping around on the &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxSwift-Ext&#34;&gt;RxSwift-Ext&lt;/a&gt; project I&amp;rsquo;d probably haven&amp;rsquo;t looked into writing unit tests with RxSwift yet, but I did - and that&amp;rsquo;s great.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look at some of the unit tests I wrote&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;intro-to-rxtests:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Intro to RxTests&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;RxTests&lt;/strong&gt; is a separate library (available as well through CocoaPods), which you should import in your test target to be able to use some really handy classes to write your tests.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the Swift-Ext Podfile test target looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;target &#39;RxSwiftExtDemoTests&#39; do
	pod &#39;RxSwift+Ext&#39;
	pod &#39;RxSwift&#39;
	pod &#39;RxTests&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;RxTests&lt;/strong&gt; gives you few handy tools like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TestableObserver&amp;lt;ElementType&amp;gt;&lt;/code&gt; - an observer, which records all emitted events so you can inspect them and run your asserts on those events,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TestScheduler&lt;/code&gt; - a scheduler which let&amp;rsquo;s you control values and time, and let&amp;rsquo;s you create testable observers,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;== (lhs: Event&amp;lt;Element&amp;gt;, rhs: Event&amp;lt;Element&amp;gt;)&lt;/code&gt; adds &lt;code&gt;Equatable&lt;/code&gt; implementation to Rx events so you can easily check recorded events.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s have a look how to use those!&lt;/p&gt;

&lt;h2 id=&#34;simple-tests-for-an-rx-operator:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Simple tests for an rx operator&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&#34;http://rx-marin.com/post/rxswift-rxcocoa-custom-convenience-operators-part2/&#34;&gt;Custom convenience operators with RxSwift, Part 2&lt;/a&gt; I discussed creating the &lt;code&gt;unwrap()&lt;/code&gt; operator, which unwraps non-&lt;code&gt;nil&lt;/code&gt; values emitted by an observable.&lt;/p&gt;

&lt;p&gt;It took me a lot of time to make that operator work so when I saw folks contribute their operators to RxSwift-Ext I naturally also wanted to merge mine in.&lt;/p&gt;

&lt;p&gt;In order to do that though, I wanted to add unit tests first&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;drafting-a-unit-test-class:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Drafting a unit test class&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s how the setup of the unit tests file for &lt;code&gt;unwrap()&lt;/code&gt; looked like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import XCTest

import RxSwift
import RxSwift_Ext
import RxTests

class UnwrapTests: XCTestCase {
    private var observer: TestableObserver&amp;lt;Int&amp;gt;!
    let numbers: Array&amp;lt;Int?&amp;gt; = [1, nil, Int?(3), 4]
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class itself is a normal &lt;code&gt;XCTestCase&lt;/code&gt; test but it features a &lt;code&gt;TestableObserver&lt;/code&gt;. You have to specify what kind of values it will observe so that you can have compile time checks if your &lt;code&gt;Observable&lt;/code&gt; is emitting the data type you expect to have.&lt;/p&gt;

&lt;p&gt;For my tests I chose to test with an array of &lt;code&gt;Int?&lt;/code&gt; values since &lt;code&gt;unwrap()&lt;/code&gt; takes in a &lt;code&gt;Type?&lt;/code&gt; and returns &lt;code&gt;Type&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;numbers&lt;/code&gt; array is the sequence of values I&amp;rsquo;d use to feed into &lt;code&gt;unwrap()&lt;/code&gt; - it includes integers, a &lt;code&gt;nil&lt;/code&gt; value, and an Optional integer number.&lt;/p&gt;

&lt;h2 id=&#34;setup:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;setUp()&lt;/h2&gt;

&lt;p&gt;Next I needed to add a &lt;code&gt;setUp()&lt;/code&gt; method in the unit test class to prepare everything before the actual test methods run.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func setUp() {
    super.setUp()
        
    let scheduler = TestScheduler(initialClock: 0)
    observer = scheduler.createObserver(Int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;At this point I dug multiple times through the RxExample app included in the RxSwift repo in order to figure out how to use a test scheduler.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First of all my tests didn&amp;rsquo;t need to happen asynchronously so I didn&amp;rsquo;t have to use virtual time for my test scheduler. I set the initial clock at time &lt;code&gt;0&lt;/code&gt; and didn&amp;rsquo;t bother with time any further.&lt;/p&gt;

&lt;p&gt;After creating a test scheduler I created a test observer by calling &lt;code&gt;TestScheduler.createObserver(Type)&lt;/code&gt;. &lt;code&gt;Type&lt;/code&gt; is the type of values I expected the observer to capture from my &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point my code was ready to emit some values, I added:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;numbers.toObservable()
     .unwrap()
     .subscribe(observer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That code turned the initial array I had to an observable, fed it through &lt;code&gt;unwrap()&lt;/code&gt;, and finally sent it off to the test observer.&lt;/p&gt;

&lt;p&gt;The final line I added to &lt;code&gt;setUp()&lt;/code&gt; was:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;scheduler.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That would make the scheduler start running, have the observer consume all values from the sequence, and wrap-up.&lt;/p&gt;

&lt;h2 id=&#34;simple-checks-on-the-recorded-events:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Simple checks on the recorded events&lt;/h2&gt;

&lt;p&gt;I decided to start easy by checking if the list of recorded events matched some general expectations.&lt;/p&gt;

&lt;p&gt;First I wanted to check if &lt;code&gt;unwrap()&lt;/code&gt; filtered all &lt;code&gt;nil&lt;/code&gt; elements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testUnwrapFilterNil() {
    XCTAssertFalse(observer.events.contains {event in
        event.value == nil
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code just checks if none of the recorded events in &lt;code&gt;observer.events&lt;/code&gt; contains a &lt;code&gt;nil&lt;/code&gt; value. Done!&lt;/p&gt;

&lt;p&gt;Ok, what next? I wanted to see if the number of the output values is the one I expect: the number of the input values minus the amount of &lt;code&gt;nil&lt;/code&gt; values plus the &lt;code&gt;Complete&lt;/code&gt; event. I just added it to the same test method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;XCTAssertEqual(
    observer.events.count,
    numbers.count - 1/* the nr. of nil elements*/ + 1 /* complete event*/
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also done! Sweet.&lt;/p&gt;

&lt;h2 id=&#34;check-the-recorded-events:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Check the recorded events&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;TestObserver&lt;/code&gt; not only records the events that your &lt;code&gt;Observable&lt;/code&gt; emits but also the values they carried and the time marks they happened at.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s really easy to check if the events you expected were the ones recorded. Let&amp;rsquo;s have a look at what I did (again, how to do all of this I found in the RxSwift repo sources):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testUnwrapResultValues() {
    //test elements values and type
    let correctValues = [
        next(0, 1),
        next(0, 3),
        next(0, 4),
        completed(0)
    ]
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I defined an array of expected events - 3 &lt;code&gt;.Next&lt;/code&gt; events all happening at virtual time &lt;code&gt;0&lt;/code&gt; and  &lt;code&gt;.Completed&lt;/code&gt; event emitted when the input values are over.&lt;/p&gt;

&lt;p&gt;Now I just needed to compare the &lt;code&gt;correctValues&lt;/code&gt; array to the list of events &lt;code&gt;TestObserver&lt;/code&gt; has recorded:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;XCTAssertEqual(observer.events, correctValues)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s a wrap!&lt;/p&gt;

&lt;h2 id=&#34;conclusion:ff7ff9c32e5286bddf9ff8fc9585d185&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It was easy and quite simple to write unit tests for &lt;code&gt;unwrap()&lt;/code&gt; because I could run all tests synchronously over the values of my input array. But &lt;code&gt;TestObserver&lt;/code&gt; and &lt;code&gt;TestScheduler&lt;/code&gt; allow for more complex unit tests as well. In part 2 I&amp;rsquo;ll look into writing simple asynchronous unit tests with RxSwift. Till then!&lt;/p&gt;

&lt;p&gt;If you want to have a look at the finished unit test class for &lt;code&gt;unwrap()&lt;/code&gt; you can find it here: &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxSwift-Ext/blob/master/Demo/RxSwiftExtDemoTests/UnwrapTests.swift#L9&#34;&gt;UnwrapTests.swift&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I hope this post has been useful! Do you know a better way to do any of this? Seen a bug? Ping me on Twitter at &lt;a href=&#34;https://twitter.com/icanzilb&#34;&gt;icanzilb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>App state with Realm and RxSwift</title>
      <link>http://rx-marin.com/post/rxswift-realm-reactive-app-settings/</link>
      <pubDate>Mon, 18 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-realm-reactive-app-settings/</guid>
      <description>

&lt;h2 id=&#34;intro:9a83a773dd09ee7268ed7c858c5ba34a&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;This post isn&amp;rsquo;t that much about operators but how to leverage the awesome technology that Realm is.&lt;/p&gt;

&lt;p&gt;Long story short - I wanted to submit an app for review and literally just before hitting submit I realized I forgot to implement a favorites filter in one of the view controllers. I would&amp;rsquo;ve quickly hacked something to send it off but since different controllers took care of the navigation bar and the actual table view showing the data could not hack my way around.&lt;/p&gt;

&lt;p&gt;So I sat down and wrote me a proper reactive app settings class to use around the app in some 10 minutes or so.&lt;/p&gt;

&lt;h2 id=&#34;the-data-model-class:9a83a773dd09ee7268ed7c858c5ba34a&#34;&gt;The data model class&lt;/h2&gt;

&lt;p&gt;Since the app uses Realm I created a new &lt;code&gt;Object&lt;/code&gt; sub-class for my app settings - this way my settings would always persist between app launches and can be observed on any thread. Here&amp;rsquo;s the AppState class I ended up with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation
import RealmSwift

class AppState: Object {
    
    dynamic var scheduleOnlyFavorites = false
    dynamic var speakersOnlyFavorites = false
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this version of the app I just want to persist whether the user has favorites-only toggled in the schedule screen and the speakers screen (it&amp;rsquo;s an event app).&lt;/p&gt;

&lt;p&gt;The default values for both properties are &lt;code&gt;false&lt;/code&gt;. When the app starts it checks whether there&amp;rsquo;s an &lt;code&gt;AppState&lt;/code&gt; object already stored in Realm and if not - creates one.&lt;/p&gt;

&lt;h2 id=&#34;app-state-subject-in-app-controller:9a83a773dd09ee7268ed7c858c5ba34a&#34;&gt;App state subject in app controller&lt;/h2&gt;

&lt;p&gt;I have an app controller class that provides few generic services so I thought it&amp;rsquo;s a good idea to add a &lt;code&gt;PublishSubject&lt;/code&gt; to it that different view controllers (and other classes) can observe.&lt;/p&gt;

&lt;p&gt;I added an &lt;code&gt;appState&lt;/code&gt; subject and a property to retain the Realm updates subscription:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class AppController {
    
    private var stateNotification: NotificationToken?
    let appState = PublishSubject&amp;lt;AppState&amp;gt;()
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;provide-app-state-updates:9a83a773dd09ee7268ed7c858c5ba34a&#34;&gt;Provide app state updates&lt;/h2&gt;

&lt;p&gt;Wiring up the app settings subject was very easy thanks to the  &lt;code&gt;addNotificationBlock&lt;/code&gt; method on Realm&amp;rsquo;s &lt;code&gt;AnyRealmCollection&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;init() {
    stateNotification = RealmProvider.appRealm.objects(AppState).addNotificationBlock {[weak self]results, error in
        if let state = results?.first, let `self` = self {
            self.appState.onNext(state)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;RealmProvider.appRealm&lt;/code&gt; returns a Realm on the current thread that points to the particle realm file I want to use for the app state.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What this code does is to fetch all objects of class &lt;code&gt;AppState&lt;/code&gt; stored in Realm and any time any time those are updated call the closure provided to &lt;code&gt;addNotificationBlock&lt;/code&gt;. The closure gets a reference to the results as its first parameter so it&amp;rsquo;s pretty easy to just fetch the first result (the only &lt;code&gt;AppState&lt;/code&gt; object in the Realm actually) and emit it as a &lt;code&gt;.Next&lt;/code&gt; event from the &lt;code&gt;appState&lt;/code&gt; subject of the app controller.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s really all there is to binding a &lt;code&gt;PublishSubject&lt;/code&gt; to any Realm result. As long as anything retains &lt;code&gt;stateNotification&lt;/code&gt; you will receive updates from Realm.&lt;/p&gt;

&lt;h2 id=&#34;observe-for-app-state-updates:9a83a773dd09ee7268ed7c858c5ba34a&#34;&gt;Observe for app state updates&lt;/h2&gt;

&lt;p&gt;Next - I wanted to observe for changes in the two settings in my persisted app settings object.&lt;/p&gt;

&lt;p&gt;So in my view model, that shows the event schedule, I added:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;UIApplication.controller.appState
.map {state in
    return state.scheduleOnlyFavorites
}
.bindTo(onlyFavorites)
.addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I observe &lt;code&gt;appState&lt;/code&gt; and map the emitted value, which is of type &lt;code&gt;AppState&lt;/code&gt;, to the value of &lt;code&gt;scheduleOnlyFavorites&lt;/code&gt;. The result is a &lt;code&gt;Bool&lt;/code&gt; value, which I just bind to another subject that I have called &lt;code&gt;onlyFavorites&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cool! Now any class could update my app settings and that&amp;rsquo;ll reflect the bindings I have in this particular view model.&lt;/p&gt;

&lt;h2 id=&#34;updating-the-app-state:9a83a773dd09ee7268ed7c858c5ba34a&#34;&gt;Updating the app state&lt;/h2&gt;

&lt;p&gt;The last piece of the puzzle was the code to run when the user toggles the favorites-only button. I went back to my app controller class and added a new method that would update my app state:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func updateState(updates: (inout AppState)-&amp;gt;Void) {
    try! RealmProvider.appRealm.write {
        var currentState = RealmProvider.appRealm.objects(AppState).first!
        updates(&amp;amp;currentState)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;updateState&lt;/code&gt; takes a closure inside which you can mutate the app state. This pattern let me create a Realm on the current thread, fetch the current app state and inject it to the user-defined updates closure.&lt;/p&gt;

&lt;p&gt;I wrapped the whole thing in a &lt;code&gt;Realm.write&lt;/code&gt; call so that it is actually allowed to mutate the state object from inside the closure.&lt;/p&gt;

&lt;h2 id=&#34;observing-for-buttons-taps-and-mutating-the-state:9a83a773dd09ee7268ed7c858c5ba34a&#34;&gt;Observing for buttons taps and mutating the state&lt;/h2&gt;

&lt;p&gt;It was finally time to wire everything together. In the view controller taking care of my navigation bar where the favorites button lives I added:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;btnFavorites.rx_tap
    .subscribeNext {[weak self]_ in
        guard let `self` = self else {return}
        UIApplication.controller.updateState {state in
            state.scheduleOnlyFavorites = self.btnFavorites.selected
        }
    }
    .addDisposableTo(bag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the user taps the favorites button I call &lt;code&gt;updateState&lt;/code&gt; and set the value of &lt;code&gt;scheduleOnlyFavorites&lt;/code&gt; to the &lt;code&gt;selected&lt;/code&gt; property of my button. &lt;code&gt;selected&lt;/code&gt; toggles between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; so that changes the app state property accordingly.&lt;/p&gt;

&lt;p&gt;As soon as my &lt;code&gt;updateState&lt;/code&gt; closure executes, app controller gets a notification from Realm that one of the stored &lt;code&gt;AppState&lt;/code&gt; objects was modified and that emits a new value from the &lt;code&gt;appState&lt;/code&gt; subject.&lt;/p&gt;

&lt;p&gt;And finally since my view models throughout the app observe that subject they update their bindings and UI throughout the app gets updated accordingly.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:9a83a773dd09ee7268ed7c858c5ba34a&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It took me very little time to add a persisted reactive app state to the project. Using Realm for the task made it very easy to have the app state reactive and accessible across classes and threads.&lt;/p&gt;

&lt;p&gt;The code in my app controller is 10-15 lines and I have another 5 lines in the data model class. How cool is that?&lt;/p&gt;

&lt;p&gt;I hope this post has been useful! Do you know a better way to do any of this? Seen a bug? Ping me on Twitter at &lt;a href=&#34;https://twitter.com/icanzilb&#34;&gt;icanzilb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Implementing state with scan in RxSwift</title>
      <link>http://rx-marin.com/post/rxswift-state-with-scan/</link>
      <pubDate>Mon, 04 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-state-with-scan/</guid>
      <description>

&lt;h2 id=&#34;intro:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Common misconception is that you cannot have state with Rx. Well you can - and there&amp;rsquo;s a special operator that helps you to: &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve ever used &lt;code&gt;reduce&lt;/code&gt; in Swift - scan is a very similar operator but &lt;code&gt;reduce&lt;/code&gt; goes over the complete sequence and gives you the final value of the accumulator while &lt;code&gt;scan&lt;/code&gt; emits each intermediate value as well.&lt;/p&gt;

&lt;p&gt;If you haven&amp;rsquo;t used &lt;code&gt;reduce&lt;/code&gt; - no worries you&amp;rsquo;ll get to understand &lt;code&gt;scan&lt;/code&gt; from the examples below. Let&amp;rsquo;s get started!&lt;/p&gt;

&lt;h2 id=&#34;creating-a-boolean-switch:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Creating a boolean switch&lt;/h2&gt;

&lt;p&gt;When you have to deal with UI you inevitably have to deal with state. Imagine a button that toggles between selected and deselected state as the user taps it repeatedly. One tap - the button is selected, another tap - it&amp;rsquo;s not, a third taps selects it again, etc.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;UIButton.rx_tap&lt;/code&gt; always emits the same value of &lt;code&gt;Void&lt;/code&gt; so it doesn&amp;rsquo;t provide you with any information to decide whether to select or deselect the button. Enter &lt;code&gt;scan&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; takes two parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;initial value - you can think of it as the first value of your state&lt;/li&gt;
&lt;li&gt;closure(lastState, newValue) - &lt;code&gt;scan&lt;/code&gt; runs that closure each time it gets a new value - it calls it with two parameters: the last state you had and the value that was just emitted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You might wander what the state is? Anything you want it to be (I know&amp;hellip; clichés) - it can be a &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, an &lt;code&gt;Array&lt;/code&gt; anything you need for your code. Let&amp;rsquo;s look at the first example to make everything click together.&lt;/p&gt;

&lt;p&gt;I had to make button get selected/deselected as described earlier so I used &lt;code&gt;scan&lt;/code&gt; in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(false) { lastState, newValue in
    return !lastState
}
.subscribeNext {value in
    print(&amp;quot;tap: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all consider how the &lt;code&gt;scan&lt;/code&gt; above transforms the data stream. It starts with &lt;code&gt;Void&lt;/code&gt; values emitted by &lt;code&gt;rx_tap&lt;/code&gt; but then scan maps those to &lt;code&gt;Bool&lt;/code&gt; values (determined by the type of its &lt;code&gt;return&lt;/code&gt; type):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(tap) &amp;mdash;&amp;gt; Void &amp;mdash;&amp;gt; (scan) &amp;mdash;&amp;gt; Bool &amp;mdash;&amp;gt; (subscribeNext)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So scan starts with a &lt;code&gt;false&lt;/code&gt; state and on each button tap it applies the closure. The first time &lt;code&gt;lastState = false&lt;/code&gt; and &lt;code&gt;newValue = Void&lt;/code&gt; (actually &lt;code&gt;newValue&lt;/code&gt; is always &lt;code&gt;Void&lt;/code&gt; so I&amp;rsquo;ll ignore till the end of this example). You return the negation of &lt;code&gt;lastState&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second time around &lt;code&gt;lastState&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; because this is what you return the first time. And your return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Third time around &lt;code&gt;lastState&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and you return &lt;code&gt;true&lt;/code&gt;. Etc. etc. etc.&lt;/p&gt;

&lt;p&gt;The console output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tap: true
tap: false
tap: true
tap: false
tap: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So as you can see you can implement state but it&amp;rsquo;s contained within the closure you supply to &lt;code&gt;scan&lt;/code&gt;. After &lt;code&gt;scan&lt;/code&gt; you get a data stream of the type your closure returns - that&amp;rsquo;s all :)&lt;/p&gt;

&lt;p&gt;So to complete the select/deselect example you just need to bind the &lt;code&gt;scan&lt;/code&gt; result to your button&amp;rsquo;s &lt;code&gt;rx_selected&lt;/code&gt; sink like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(false) { lastState, newValue in
    return !lastState
}
.bindTo(myButton.rx_selected)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-a-counter:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Creating a counter&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s get beyond alternating between &lt;code&gt;Bool&lt;/code&gt; values and write a code to count how many times a button has been tapped.&lt;/p&gt;

&lt;p&gt;I actually had to do this few times in the last couple months so I&amp;rsquo;ll just put in here the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myButton.rx_tap.scan(0) { lastCount, newValue in
    return lastCount + 1
}
.subscribeNext {value in
    print(&amp;quot;taps: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time around the state is of type &lt;code&gt;Int&lt;/code&gt; and it starts with &lt;code&gt;0&lt;/code&gt;. Each time the user taps the button &lt;code&gt;scan&lt;/code&gt; returns the last count plus 1. As the user taps the button the Console shows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;taps: 1
taps: 2
taps: 3
taps: 4
taps: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you grasp how the last state thing works it&amp;rsquo;s pretty easy isn&amp;rsquo;t it? :)&lt;/p&gt;

&lt;h2 id=&#34;geting-the-last-n-values:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Geting the last N values&lt;/h2&gt;

&lt;p&gt;Somebody in the RxSwift Slack asked for this and it&amp;rsquo;s an interesting (but very simple to solve) example.&lt;/p&gt;

&lt;p&gt;How to get the last N elements from an Observable?&lt;/p&gt;

&lt;p&gt;For example if you have a sequence of &lt;code&gt;Int&lt;/code&gt; values: &lt;code&gt;[0, 1, 2, 3, 4, 5, 6]&lt;/code&gt; how to have the last 3 each time a new value is emitted?&lt;/p&gt;

&lt;p&gt;Well, this smells like having a state since you need to &amp;ldquo;&lt;em&gt;remember&lt;/em&gt;&amp;rdquo; values. So it must be solvable with &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Obviously the first time the sequence emits you don&amp;rsquo;t have any previous values so the initial state to give to &lt;code&gt;scan&lt;/code&gt; is an empty array &lt;code&gt;[]&lt;/code&gt;. Let&amp;rsquo;s have a look at the complete code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let numbers = [0, 1, 2 , 3, 4, 5, 6].toObservable()

numbers.scan([]) { lastSlice, newValue in
    return Array(lastSlice + [newValue]).suffix(3)
}
.subscribeNext {value in
    print(&amp;quot;last 3: \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time &lt;code&gt;scan&lt;/code&gt; adds the emitted value to the last array you had and than chops 3 elements off the end. Now the data stream looks like so:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(numbers) &amp;mdash;&amp;gt; Int &amp;mdash;&amp;gt; (scan) &amp;mdash;&amp;gt; [Int] &amp;mdash;&amp;gt; subscribeNext&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And the Console output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;last 3: [0]
last 3: [0, 1]
last 3: [0, 1, 2]
last 3: [1, 2, 3]
last 3: [2, 3, 4]
last 3: [3, 4, 5]
last 3: [4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But didn&amp;rsquo;t I say I wanted elements of three? Just &lt;code&gt;filter&lt;/code&gt; the output of &lt;code&gt;scan&lt;/code&gt; and check for the length of the emitted array and that&amp;rsquo;s it ;)&lt;/p&gt;

&lt;h2 id=&#34;using-enums-for-state:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Using enums for state&lt;/h2&gt;

&lt;p&gt;I didn&amp;rsquo;t have to do any more advanced &lt;code&gt;scan&lt;/code&gt; stuff yet but I can imagine all kinds of uses for it. Let&amp;rsquo;s say you&amp;rsquo;re building a space game.&lt;/p&gt;

&lt;p&gt;When you start a level in your space game your ship has to make it through an asteroid field. Therefore the longer the ship is &amp;ldquo;alive&amp;rdquo; the more points you get, etc.&lt;/p&gt;

&lt;p&gt;So you can build a timer that tracks the level time and bind the level state and the amount of points earned like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum LevelState {
    case Normal, PowerUp
}

let timer = Observable&amp;lt;NSInteger&amp;gt;.interval(0.25, scheduler: MainScheduler.instance)

timer.scan((LevelState.Normal, 0)) { lastState, _ in
    
    switch lastState.0 {
    case .Normal:
        if lastState.1 &amp;gt; 1000 {
            return (.PowerUp, lastState.1 + 30)
        } else {
            return (.Normal, lastState.1 + 30)
        }
    case .PowerUp:
        return (.PowerUp, lastState.1 + 100)
    }
}
.subscribeNext {_, points in
    print(&amp;quot;pts: \(points)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You have two states in your level - normal mode and power-up. Once the player manages to survive past 1,000 points they start gaining more points much faster. To do that you have two states listed in an enum &lt;code&gt;LevelState&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The state is a tuple of type &lt;code&gt;(LevelState, Int)&lt;/code&gt; - the first element tracks the current level state, and second is the points counter.&lt;/p&gt;

&lt;p&gt;And this is still a pretty simple example of what is possible with &lt;code&gt;scan&lt;/code&gt; and few lines of code. Woot!&lt;/p&gt;

&lt;p&gt;Look those numbers fly once you&amp;rsquo;re past the &lt;code&gt;1,000&lt;/code&gt; mark!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pts: 810
pts: 840
pts: 870
pts: 900
pts: 930
pts: 960
pts: 990
pts: 1020
pts: 1050
pts: 1150
pts: 1250
pts: 1350
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion:af2be6c694d253c59ac4efd5a73d0daf&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; is simply fantastic and as I wrote in an earlier post - any time you&amp;rsquo;re tempted to use &lt;code&gt;reduce&lt;/code&gt; you probably need &lt;code&gt;scan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I hope that post has been useful and if you have any operator that bums you out or can&amp;rsquo;t figure out ping me on Twitter - I&amp;rsquo;m also still learning but have few of those figured out pretty well :)&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on Twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom bindings with RxSwift</title>
      <link>http://rx-marin.com/post/rxswift-rxcocoa-custom-bindings/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://rx-marin.com/post/rxswift-rxcocoa-custom-bindings/</guid>
      <description>

&lt;h2 id=&#34;intro:d4dcb38b814640de6df8a9df2675e24b&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;After I did some convenience operators of my own, which really made things easier while writing code I thought I&amp;rsquo;d be a good idea to look into building more stuff on my own.&lt;/p&gt;

&lt;p&gt;It helps learning and it&amp;rsquo;s healthy :)&lt;/p&gt;

&lt;h2 id=&#34;binding-to-make-a-view-visible:d4dcb38b814640de6df8a9df2675e24b&#34;&gt;Binding to make a view visible&lt;/h2&gt;

&lt;p&gt;I noticed there is a binding on the &lt;code&gt;hidden&lt;/code&gt; property of &lt;code&gt;UIView&lt;/code&gt; but sometimes the code just reads better when you don&amp;rsquo;t have to think of &lt;em&gt;hiding something&lt;/em&gt; but rather &lt;strong&gt;showing something&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So I thought since I can check out the source code for &lt;code&gt;rx_hidden&lt;/code&gt; how hard could it be to make my own &lt;code&gt;rx_visible&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;So I just copied over the code and made my first bindable sink:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension UIView {
    public var rx_visible: AnyObserver&amp;lt;Bool&amp;gt; {
        return UIBindingObserver(UIElement: self) { view, visible in
            view.hidden = !visible
        }.asObserver()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I know that isn&amp;rsquo;t a great departure from &lt;code&gt;rx_hidden&lt;/code&gt; but sometimes it really makes more sense (and it&amp;rsquo;s more readable) to use &lt;code&gt;rx_visible&lt;/code&gt;. Let&amp;rsquo;s look:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;//longer, logic is reversed
isEnabled.map {enabled in !enabled}.bindTo(messageView.rx_hidden)

//short and sweet
isEnabled.bindTo(messageView.rx_visible)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really like the latter a bit better! So far so good :)&lt;/p&gt;

&lt;h2 id=&#34;binding-for-becoming-and-resigning-first-responder:d4dcb38b814640de6df8a9df2675e24b&#34;&gt;Binding for becoming and resigning first responder&lt;/h2&gt;

&lt;p&gt;Next - I felt like building something that would actually add functionality it isn&amp;rsquo;t already in.&lt;/p&gt;

&lt;p&gt;In the project I&amp;rsquo;m currently working on I have a search bar and I have few buttons that show and hide the search bar depending on what the user wants to do.&lt;/p&gt;

&lt;p&gt;Therefore I thought it&amp;rsquo;d be great to make my own bindable sink for being a first responder.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension UIResponder {
    public var rx_firstResponder: AnyObserver&amp;lt;Bool&amp;gt; {
        return UIBindingObserver(UIElement: self) {control, shouldRespond in
            shouldRespond ? control.becomeFirstResponder() : control.resignFirstResponder()
        }.asObserver()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example isn&amp;rsquo;t more complex than the previous one. It&amp;rsquo;s a bindable &lt;code&gt;Bool&lt;/code&gt; property, which either makes the control become or resign first responder.&lt;/p&gt;

&lt;p&gt;Now I could group the show and hide buttons into one observable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let searchBarActive = [btnSearch.rx_tap.replaceWith(true), searchBarBtnCancel.replaceWith(false)].toObservable()
  .merge()
  .startWith(false)
  .shareReplay(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And besides all the other changes in the UI make the search bar active or force it to lose focus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;searchBarActive.bindTo(searchController.searchBar.rx_firstResponder)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neat! Since I started writing rx code I&amp;rsquo;ve really grown to dislike having &lt;code&gt;if&lt;/code&gt; operators (also &lt;code&gt;var&lt;/code&gt; but that&amp;rsquo;s a whole other story)&lt;/p&gt;

&lt;h2 id=&#34;conclusion:d4dcb38b814640de6df8a9df2675e24b&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Okay so creating simple on-the-fly cocoa bindings is easy. But is it worth it if it&amp;rsquo;s so easy?&lt;/p&gt;

&lt;p&gt;I like bindings better than writing code to update the UI. No &lt;code&gt;if&lt;/code&gt; and no closures to update the UI - no problem. I know other people prefer to not use RxCocoa at all and just use RxSwift and update the UI themselves.&lt;/p&gt;

&lt;p&gt;I guess either is okay :)&lt;/p&gt;

&lt;p&gt;Do you know a better way to do any of this? Seen a bug? Ping me on Twitter.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>